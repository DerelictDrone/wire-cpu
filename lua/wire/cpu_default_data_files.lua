//{"gpuchip/":{"gpuchip/examples/":{"gpuchip/examples/sprite.txt":"// Author: Drunkie\r\n// Description: A very simple sprite example\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nvoid Main()\r\n{\r\n    // Enable vertex mode\r\n    glVertexMode( 1 );\r\n\r\n    // Draw to sprite buffer\r\n    glSetRenderTarget( GL_BUFFER_BACK );\r\n    glClear( 0, 255, 0 );\r\n\r\n    // Draw to vertex buffer (world)\r\n    glSetRenderTarget( GL_BUFFER_VERTEX );\r\n    glEnable( GL_VERTEX_TEXTURING );\r\n\r\n    // Sample from sprite 0\r\n    glTextureSize( 256 );\r\n    glTexture( 0 );\r\n    glClear( 0, 255, 0 );\r\n    glRectWH( 128, 128, 256, 256 );\r\n\r\n    glSetRenderTarget( GL_BUFFER_FRONT );\r\n\r\n    glExit();\r\n}\r\n","gpuchip/examples/3d_icosahedron.txt":"// Author: Drunkie\r\n// Description: Draws a 3D icosahedron model (solid and wireframe)\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nvoid Main()\r\n{\r\n    glSleep( 40 ); // Sleep for 40 milliseconds (Reduces fps lag)\r\n    glClear( 0, 0, 0 ); // Clear screen\r\n\r\n    glCoordPipe( GL_CPIPE_N1_1 ); // Set coordinate pipe to [-1 to 1] mode\r\n    glVertexPipe( GL_VPIPE_XYZTRANSFORM ); // Set vertex pipe to xyz transformation\r\n\r\n    glLightPos( 0, 0, -50 ); // Set the light position\r\n    glLightColor( 255, 255, 255, 1 ); // Set the light color\r\n\r\n    glLookAt(\r\n        0, 0, -2.25, // Camera pos\r\n        0, 0, 0, // Camera target\r\n        0, 1, 0 // Camera up\r\n    );\r\n\r\n    // Create variable to hold curtime\r\n    float time;\r\n    timer time;\r\n\r\n    // Create perspective and matrix transformations\r\n    glPerspective( 30, 1, 1, 20 ); // FOV, ASPECT RATIO, ZNEAR, ZFAR\r\n    glRotate( 1, 1, 0, time ); // AXIS X, Y, Z, ANGLE W\r\n    glTranslate( 0, 0, 0 ); // TRANSLATION X, Y, Z\r\n    glScale( 1, 1, 1, 0 ); // SCALE X, Y, Z\r\n\r\n    glEnable( GL_VERTEX_BUFFER ); // Enable vertex buffer\r\n    glEnable( GL_VERTEX_ZSORT ); // Enable Z sorting\r\n    glEnable( GL_VERTEX_LIGHTING ); // Enable vertex lighting\r\n    //glEnable( GL_VERTEX_CULLING ); // Enable face culling\r\n\r\n    // Solid 3D polygon\r\n    glFillMode( GL_FILL_SOLID ); // Set fillmode as solid\r\n    glColor4( 100, 149, 237, 180 ); // Set the draw color with alpha\r\n    glPoly3D( vertexBuffer, 20 ); // Draw 3D polygon\r\n    glFlush(); // Flush the vertex buffer to the screen\r\n\r\n    glDisable( GL_VERTEX_LIGHTING ); // Enable vertex lighting\r\n\r\n    // Wireframe 3D polygon\r\n    glLineWidth( 1 ); // Set line width of wireframe\r\n    glFillMode( GL_FILL_WIREFRAME ); // Set fillmode as wireframe\r\n    glColor4( 255, 255, 255, 255 ); // Set the draw color with alpha\r\n    glPoly3D( vertexBuffer, 20 ); // Draw 3D polygon\r\n    glFlush(); // Flush the vertex buffer to the screen\r\n\r\n    glExit(); // Exit\r\n}\r\n\r\n// The vertex data for our model\r\nvertexBuffer:\r\ndb 0,0,1; db 0,0.9,0.5; db 0.9,0.3,0.4;\r\ndb 0,0,1; db -0.9,0.3,0.4; db 0,0.9,0.5;\r\ndb 0,0,1; db -0.5,-0.7,0.4; db -0.9,0.3,0.4;\r\ndb 0,0,1; db 0.5,-0.7,0.4; db -0.5,-0.7,0.4;\r\ndb 0,0,1; db 0.9,0.3,0.4; db 0.5,-0.7,0.4;\r\ndb 0.9,-0.3,-0.4; db 0.9,0.3,0.4; db 0.5,0.7,-0.4;\r\ndb 0,0.9,0.5; db 0.5,0.7,-0.4; db 0.9,0.3,0.4;\r\ndb 0,0.9,0.5; db -0.5,0.7,-0.4; db 0.5,0.7,-0.4;\r\ndb 0,0.9,0.5; db -0.9,0.3,0.4; db -0.5,0.7,-0.4;\r\ndb -0.9,-0.3,-0.4; db -0.5,0.7,-0.4; db -0.9,0.3,0.4;\r\ndb -0.9,-0.3,-0.4; db -0.9,0.3,0.4; db -0.5,-0.7,0.4;\r\ndb -0.9,-0.3,-0.4; db -0.5,-0.7,0.4; db 0,-0.9,-0.5;\r\ndb 0.5,-0.7,0.4; db 0,-0.9,-0.5; db -0.5,-0.7,0.4;\r\ndb 0.5,-0.7,0.4; db 0.9,-0.3,-0.4; db 0,-0.9,-0.5;\r\ndb 0.5,-0.7,0.4; db 0.9,0.3,0.4; db 0.9,-0.3,-0.4;\r\ndb 0,0,-1; db 0,-0.9,-0.5; db 0.9,-0.3,-0.4;\r\ndb 0,0,-1; db 0.9,-0.3,-0.4; db 0.5,0.7,-0.4;\r\ndb 0,0,-1; db 0.5,0.7,-0.4 db -0.5,0.7,-0.4;\r\ndb 0,0,-1; db -0.5,0.7,-0.4; db -0.9,-0.3,-0.4;\r\ndb 0,0,-1; db -0.9,-0.3,-0.4; db 0,-0.9,-0.5;\r\n","gpuchip/examples/mt3.txt":"//== 3D Graphics begin here ====================================================\r\n  dvxpipe 3;\r\n  dcvxpipe 3;\r\n\r\n  //Calc depth here\r\n  mov #Background.MinDepth,  0.8; //Near distance\r\n  mov #Background.MaxDepth,  6.0; //Far distance\r\n  mov #Background.ShadeStart,1.0;\r\n  mov #Background.DepthStep ,0.3; //Depth step. The lower, the higher quality is\r\n\r\n  timer #Time; mul #Time,3;\r\n\r\n  mov EAX,#Time; mod EAX,#Background.DepthStep;\r\n\r\n  sub #Background.MinDepth,EAX;\r\n  sub #Background.MaxDepth,EAX;\r\n\r\n  //Initialize depth range\r\n  mov  #Background.deltaDepth,#Background.MaxDepth;\r\n  sub  #Background.deltaDepth,#Background.MinDepth;\r\n\r\n  //Compute background stuff\r\n  mov  #Background.ShadeStep,#Background.deltaDepth;\r\n  div  #Background.ShadeStep,#Background.DepthStep;\r\n  frnd #Background.ShadeStep;\r\n  finv #Background.ShadeStep;\r\n  mul  #Background.ShadeStep,#Background.ShadeStepMul;\r\n\r\n  //Brightness too\r\n  mov EAX,#Time; mod EAX,#Background.ShadeStep;\r\n  sub #Background.ShadeStart,EAX;\r\n\r\n  mov #_rect.color.r,200;\r\n  mov #_rect.color.b,200;\r\n\r\n// Uncomment this for trippy camera\r\n//  timer EAX; div EAX,8; fsin EBX,EAX; mul EBX,2;\r\n//  drotatescale EAX,EBX; mul EBX,2;\r\n\r\n  dsetwidth 0.8;\r\n  call Draw.Background;\r\ndexit;\r\n\r\nalloc Time;\r\n\r\n//==============================================================================\r\nDraw.Background:\r\n  //Draw all the rectangles\r\n  mov EAX,#Background.MinDepth; mov ECX,#Background.ShadeStart;\r\n  BackgroundLoop:\r\n    mov EDX,#Time; add EDX,EAX;\r\n    mov EBP,#Time; div EBP,6.28; fcos EBP,EBP;\r\n\r\n    fsin EDI,EDX; mul EDI,EBP; mul EDI,0.8; sub EDI,1;\r\n    mov #_rect.offset.x,EDI;\r\n\r\n    fcos ESI,EDX; mul ESI,EBP; mul ESI,0.4; sub ESI,1;\r\n    mov #_rect.offset.y,ESI;\r\n\r\n    mov EDX,ECX; fpwr EDX,2;\r\n    mov #regZOffset,EAX;\r\n\r\n    dcolor _rect.color;\r\n// Uncomment this for trippy HSL color\r\n//    mov ESI,#Time; add ESI,EAX;\r\n//    fsin #HSL.R,ESI; mul #HSL.R,127; add #HSL.R,128; add ESI,1.57;// mul EAX,2;\r\n//    fsin #HSL.G,ESI; mul #HSL.G,127; add #HSL.G,128; add ESI,1.57;// mul EAX,2;\r\n//    fsin #HSL.B,ESI; mul #HSL.B,127; add #HSL.B,128;\r\n//\r\n//    dcolor HSL;\r\n    dshade EDX;\r\n    dorectwh _rect.offset,_rect.wh;\r\n\r\n    sub ECX,#Background.ShadeStep;\r\n    add EAX,#Background.DepthStep;\r\n\r\n    cmp EAX,#Background.MaxDepth;\r\n    jl BackgroundLoop;\r\nret\r\n\r\n//==============================================================================\r\n//Drawing parameters\r\nscalar Background.MinDepth;\r\nscalar Background.MaxDepth;\r\nscalar Background.deltaDepth;\r\nscalar Background.DepthStep;\r\nscalar Background.ShadeStart;\r\nscalar Background.ShadeStep;\r\nscalar Background.ShadeStepMul,0.5;\r\n\r\ncolor HSL;\r\n\r\n//Generic rectangle\r\nvector2f _rect.offset,-1,-1;\r\nvector2f _rect.wh,2,2;\r\n\r\nvector2f _pad1.offset;\r\nvector2f _pad2.offset;\r\nvector2f _pad.wh;\r\n\r\n//Color scheme\r\ncolor _rect.color, 200,200,200;\r\ncolor _rect.color2,200,200,000;\r\n\r\ncolor _pad1.color, 000,200,000;\r\ncolor _pad2.color, 200,000,000;\r\n","gpuchip/examples/cube.txt":"//timer EAX;// div EAX,8;\r\n//fsin EAX,EAX;\r\n//mul EAX,512;\r\n//fabs EAX,EAX;\r\n//neg EAX;\r\n//add EAX,512;\r\n\r\ndcvxpipe 3; //-1..1 (opengl screen)\r\ndvxpipe  5; //matrix projection\r\n\r\n//Initialize transform\r\nmperspective mProjectionMatrix,vPerspective;\r\n\r\n//Render starts\r\ndclrscr  bg_color;\r\nmlookat mViewMatrix,vLookAt; //View matrix\r\n\r\ntimer eax;\r\nmov #vRotate.w,eax;\r\n\r\n//Rotate translate\r\nmrotate mRotateMatrix,vRotate;\r\nmtranslate mTranslateMatrix,vTranslate;\r\n\r\n//Create model matrix\r\nmmov mModelMatrix,mTranslateMatrix;\r\nmmul mModelMatrix,mRotateMatrix;\r\n\r\n//modelViewMatrix = ViewMatrix * modelMatrx\r\nmmov mModelViewMatrix,mViewMatrix;\r\nmmul mModelViewMatrix,mModelMatrix;\r\n\r\n//load matrix\r\nmload mModelViewMatrix;\r\nmloadproj mProjectionMatrix;\r\n\r\n//setup light\r\ndsetlight 0,lightdata;\r\n\r\n//setup buffer\r\ndenable 0; //Vertex buffer\r\ndenable 1; //ZSorting\r\ndenable 2; //Lighting\r\ndenable 3; //Face culling\r\n\r\n//render cube\r\ndcolor fg_color;\r\ndvxdata_3f cube2,12;\r\ndvxflush;\r\n\r\nddisable 0; //Disable everything!\r\nddisable 1;\r\nddisable 2;\r\nddisable 3;\r\n\r\ndcvxpipe 0;\r\ndvxpipe  0;\r\n\r\n//You can write some text here now\r\n//<right here>\r\ndexit;\r\n\r\n//========\r\ncube2:\r\ndb -1,-1,-1;\r\ndb 1,-1,-1;\r\ndb 1,1,-1;\r\ncube3:\r\ndb -1,-1,-1;\r\ndb 1,1,-1;\r\ndb -1,1,-1;\r\ncube4:\r\ndb 1,-1,1;\r\ndb -1,-1,1;\r\ndb 1,1,1;\r\ncube5:\r\ndb -1,-1,1;\r\ndb -1,1,1;\r\ndb 1,1,1;\r\ncube6:\r\ndb 1,-1,-1;\r\ndb -1,-1,-1;\r\ndb 1,-1,1;\r\ncube7:\r\ndb -1,-1,-1;\r\ndb -1,-1,1;\r\ndb 1,-1,1;\r\ncube8:\r\ndb -1,1,-1;\r\ndb 1,1,-1;\r\ndb 1,1,1;\r\ncube9:\r\ndb -1,1,1;\r\ndb -1,1,-1;\r\ndb 1,1,1;\r\ncube10:\r\ndb -1,-1,-1;\r\ndb -1,1,-1;\r\ndb -1,1,1;\r\ncube11:\r\ndb -1,-1,1;\r\ndb -1,-1,-1;\r\ndb -1,1,1;\r\ncube12:\r\ndb 1,1,-1;\r\ndb 1,-1,-1;\r\ndb 1,1,1;\r\ncube13:\r\ndb 1,-1,-1;\r\ndb 1,-1,1;\r\ndb 1,1,1;\r\n\r\nlightdata:\r\nvector4f lightpos,  0,50,-50,  0; //x y z <unused, will be falloff>\r\ncolor    lightcol,255,255,255,  1; //R G B Brightness\r\n//========\r\n\r\nmatrix mRotateMatrix;\r\nmatrix mTranslateMatrix;\r\n\r\nmatrix mProjectionMatrix;\t//This defines our projection to screen\r\nmatrix mViewMatrix;\t\t//This defines our camera transformations\r\n\r\nmatrix mModelMatrix;\t\t//This is our model transformations\r\nmatrix mModelViewMatrix;\t//This is our model relatively to camera transform\r\n\r\n\r\nvector4f vRotate,      1,  1,  1,  0; //<AXIS X Y Z> <ANGLE W>\r\nvector4f vTranslate,   0,  0,  0,  0; //<TRANLSATION X Y Z> <0>\r\nvector4f vPerspective, 30, 1.6,  1,  20; //<FOV> <ASPECT RATIO> <ZNEAR> <ZFAR>\r\n\r\nvLookAt:\r\nvector3f vLookAt_Eye,    0, 0, -5; //Where our camera is\r\nvector3f vLookAt_Center, 0, 0, 0;  //What we look at\r\nvector3f vLookAt_Up,     0, 1, 0;  //Where our matt-hat is\r\n\r\ncolor fg_color,255,255,25;\r\ncolor bg_color,64,32,12;\r\n","gpuchip/examples/verynice2.txt":"//Generated by WGUI tool. Get it at wiremod.com\r\n_page_0:\r\ndsetsize 16\r\ndcolor _c_0\r\ndrect _a_1,_a_2\r\ndcolor _c_1\r\ndrect _a_4,_a_5\r\ndcolor _c_2\r\ndrect _a_7,_a_8\r\ndcolor _c_3\r\ndrect _a_10,_a_11\r\ndcolor _c_3\r\ndrect _a_13,_a_14\r\ndcolor _c_2\r\nmov #_f_17,port0\r\ndwrite _a_16,_s_17\r\ndcolor _c_4\r\ndrect _a_19,_a_20\r\ndcolor _c_2\r\nmov #_f_23,port0\r\ndwrite _a_22,_s_23\r\ndcolor _c_4\r\ndwritefmt _a_25,_s_26\r\ndcolor _c_4\r\ndwritefmt _a_28,_s_29\r\ndcolor _c_4\r\ndwritefmt _a_31,_s_32\r\ndcolor _c_4\r\ndwritefmt _a_34,_s_35\r\ndcolor _c_4\r\ndwritefmt _a_37,_s_38\r\ndcolor _c_4\r\ndwritefmt _a_40,_s_41\r\ndcolor _c_4\r\ndwritefmt _a_43,_s_44\r\ndcolor _c_4\r\ndwritefmt _a_46,_s_47\r\ndcolor _c_3\r\ndrect _a_49,_a_50\r\ndcolor _c_2\r\nmov #_f_53,port0\r\ndwrite _a_52,_s_53\r\ndcolor _c_3\r\ndrect _a_55,_a_56\r\ndcolor _c_2\r\nmov #_f_59,port0\r\ndwrite _a_58,_s_59\r\ndcolor _c_2\r\ndwritefmt _a_61,_s_62\r\ndcolor _c_2\r\ndwritefmt _a_64,_s_65\r\ndcolor _c_2\r\ndwritefmt _a_67,_s_68\r\ndcolor _c_2\r\ndwritefmt _a_70,_s_71\r\ndcolor _c_2\r\ndwritefmt _a_73,_s_74\r\ndcolor _c_2\r\ndwritefmt _a_76,_s_77\r\ndexit\r\n\r\ncolor _c_0,0,0,160\r\nvec2f _a_1,8,8\r\nvec2f _a_2,504,504\r\ncolor _c_1,7,51,122\r\nvec2f _a_4,16,16\r\nvec2f _a_5,496,496\r\ncolor _c_2,0,0,0\r\nvec2f _a_7,24,24\r\nvec2f _a_8,488,488\r\ncolor _c_3,192,192,192\r\nvec2f _a_10,32,32\r\nvec2f _a_11,480,216\r\nvec2f _a_13,32,224\r\nvec2f _a_14,480,392\r\nvec2f _a_16,40,40\r\nstring _s_17,'VERYNICE GUI V2.1 Initialized...'\r\nalloc _f_17,0\r\ncolor _c_4,128,128,128\r\nvec2f _a_19,32,64\r\nvec2f _a_20,480,72\r\nvec2f _a_22,40,232\r\nstring _s_23,'Raw data feed:'\r\nalloc _f_23,0\r\nvec2f _a_25,88,256\r\nstring _s_26,'Input port 0: %f'\r\nvec2f _a_28,88,272\r\nstring _s_29,'Input port 1: %f'\r\nvec2f _a_31,88,288\r\nstring _s_32,'Input port 2: %f'\r\nvec2f _a_34,88,304\r\nstring _s_35,'Input port 3: %f'\r\nvec2f _a_37,88,320\r\nstring _s_38,'Input port 4: %f'\r\nvec2f _a_40,88,336\r\nstring _s_41,'Input port 5: %f'\r\nvec2f _a_43,88,352\r\nstring _s_44,'Input port 6: %f'\r\nvec2f _a_46,88,368\r\nstring _s_47,'Input port 7: %f'\r\nvec2f _a_49,32,400\r\nvec2f _a_50,248,480\r\nvec2f _a_52,40,408\r\nstring _s_53,'Vector feed 1:'\r\nalloc _f_53,0\r\nvec2f _a_55,264,400\r\nvec2f _a_56,480,480\r\nvec2f _a_58,272,408\r\nstring _s_59,'Vector feed 2:'\r\nalloc _f_59,0\r\nvec2f _a_61,40,424\r\nstring _s_62,'X: %f'\r\nvec2f _a_64,40,440\r\nstring _s_65,'Y: %f'\r\nvec2f _a_67,40,456\r\nstring _s_68,'Z: %f'\r\nvec2f _a_70,272,424\r\nstring _s_71,'X: %f'\r\nvec2f _a_73,272,440\r\nstring _s_74,'Y: %f'\r\nvec2f _a_76,272,456\r\nstring _s_77,'Z: %f'\r\n","gpuchip/examples/verynice1.txt":"dcolor c1;\r\ndrect p1,p2;\r\ndcolor c2;\r\ndrect p3,p4;\r\ndcolor c3;\r\ndrect p5,p6;\r\n\r\nmov #textpos1.y,80;\r\n\r\ndcolor c4;\r\ndsetsize 12;\r\ndwrite textpos1,text1;\r\n\r\nmov ecx,0;\r\nport_loop:\r\n  add #textpos1.y,18;\r\n  mov #textpos2.y,#textpos1.y;\r\n\r\n  mov #textpos2.x,#textpos1.x;\r\n  add #textpos2.x,90;\r\n  dwrite textpos1,text2;\r\n  dwritei textpos2,ecx;\r\n\r\n  in eax,ecx;\r\n\r\n  mov #textpos2.x,#textpos1.x;\r\n  add #textpos2.x,192;\r\n  dwritef textpos2,eax;\r\n\r\n  inc ecx;\r\n  cmp ecx,18;\r\n  jl port_loop;\r\n\r\ndexit;\r\n\r\nstring text1,'VERYNICE HUD SYSTEM INITIALIZED... VER 1.0';\r\nstring text2,'INPUT PORT        VALUE';\r\n\r\nvec2f textpos1,80,80;\r\nvec2f textpos2,80,80;\r\n\r\ncolor c1,0,0,255;\r\ncolor c2,0,0,127;\r\ncolor c3,0,0,64;\r\ncolor c4,255,255,255;\r\n\r\nvec2f p1,50,50;\r\nvec2f p2,450,450;\r\n\r\nvec2f p3,60,60;\r\nvec2f p4,430,430;\r\n\r\nvec2f p5,70,70;\r\nvec2f p6,440,440;\r\n","gpuchip/examples/trig.txt":"// Author: Jasongamer\r\n// Description: A tool for helping people learn trig\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nvoid Main()\r\n{\r\n    glClear( 0, 0, 0 ); // Clear screen\r\n    glCoordPipe( GL_CPIPE_N1_1 ); // Set coordinate pipe (-1 to 1 mode)\r\n\r\n    timer R0; // Set time to curtime()\r\n    R0 = -R0 * 1;\r\n\r\n    glColor( 255, 255, 255 ); // Set draw color\r\n    glCircle( *orig.x, *orig.y, 0.66, 40 ); // Draw circle (x, y, radius, quality)\r\n\r\n    glColor( 0, 0, 0 );\r\n    glCircle( *orig.x, *orig.y, 0.64, 40 );\r\n\r\n    // Set the points for the trig\r\n    fcos *cos,R0;\r\n    fsin *sin,R0;\r\n\r\n    *PosR.x = *cos;\r\n    *PosR.x *= 0.65;\r\n    *PosR.x += *orig.x;\r\n\r\n    *PosR.y = *sin;\r\n    *PosR.y *= 0.65;\r\n    *PosR.y += *orig.y;\r\n\r\n    *PosX.x = *PosR.x;\r\n\r\n    glLineWidth( 0.01 ); // Set line width\r\n    glFontSize( 24 ); // Set font size\r\n\r\n    // X part of triangle\r\n    glColor( 0, 0, 255 );\r\n    glLine( *orig.x, *orig.y, *PosX.x, *PosX.y ); // Draw line\r\n    glWriteFmt( -0.95, -0.95, sCos ) // Write formatted string\r\n\r\n    // Y part of triangle\r\n    glColor( 255, 0, 0 );\r\n    glLine( *PosR.x, *PosR.y, *PosX.x, *PosX.y );\r\n    *sin *= -1; // Negate\r\n    glWriteFmt( -0.95, -0.85, sSin );\r\n\r\n    glColor( 255, 255, 255 );\r\n    glLine( *orig.x, *orig.y, *PosR.x, *PosR.y ); // Draw line\r\n\r\n    glExit(); // Exit\r\n}\r\n\r\nvec2f orig,0,0;\r\nvec2f PosR,0,0;\r\nvec2f PosX,0,0;\r\n\r\nstring sCos,\"Cosine = %f\";\r\nalloc cos;\r\n\r\nstring sSin,\"Sine   = %f\";\r\nalloc sin;\r\n","gpuchip/examples/texture.txt":"// Author: Drunkie\r\n// Description: A very simple texture example\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nvoid Main()\r\n{\r\n    glVertexMode( 1 );\r\n    glColor( 255, 255, 255, 255 );\r\n\r\n    glBindTexture( 'brick/brick_model' );\r\n    glColor( 255, 255, 255, 255 );\r\n    glRectWH( 128, 128, 256, 256 );\r\n\r\n    glExit();\r\n}\r\n\r\n// ZASM version\r\n\r\n//mov #regVertexMode,1;\r\n//dcolor white;\r\n//dxtexture tex;\r\n//drectwh pos,size;\r\n//dexit;\r\n//color white,255,255,255;\r\n//string tex,'brick/brick_model';\r\n//vec2f pos,128,128;\r\n//vec2f size,256,256;\r\n","gpuchip/examples/terrain.txt":"// Matrix code is based on cube example\r\nDCPIPE 3 // -1 to 1 coordinate range, required by DDTERRAIN\r\nDVXPIPE 5 // XYZ projection + matrix\r\n\r\nDENABLE 0 // Vertex buffer\r\nDENABLE 1 // Z sorting\r\nDENABLE 2 // Lighting\r\nDENABLE 3 // Backface culling\r\n\r\nDSETLIGHT 0, Light\r\n\r\nMPERSPECTIVE ProjectionMatrix, Perspective\r\n\r\n// Rotate the terrain\r\nTIMER EAX\r\nDIV EAX, 4\r\nMOV #RotateVector.w, EAX\r\nMROTATE RotateMatrix, RotateVector\r\n\r\n// Point camera at terrain\r\nMLOOKAT ViewMatrix, LookAtArgs\r\nMMUL ViewMatrix, RotateMatrix\r\n\r\nMLOAD ViewMatrix\r\nMLOADPROJ ProjectionMatrix\r\n\r\nDCLRSCR Background\r\n\r\nDCOLOR Foreground\r\n//DXTEXTURE Texture // Doesn't work\r\nDDTERRAIN Terrain\r\n\r\nDVXFLUSH\r\n\r\nDEXIT\r\n\r\nCOLOR Foreground, 253, 186, 49, 255\r\nCOLOR Background, 1, 46, 87, 255\r\nCOLOR White, 255, 255, 255, 255\r\n\r\n//STRING Texture, \"brick/brick_model\";\r\n\r\n// The terrain struct\r\nTerrain:\r\n    DB 8, 8 // Terrain size\r\n    DB 16   // Draw distance, between 0 and 16\r\n    DB 0, 0 // Terrain offset\r\n\r\n    // 11 bytes unused\r\n    DB 0,0,0,0,0,0\r\n    DB 0,0,0,0,0\r\n\r\n    // 8 x 8 heightmap\r\n    DB  0.0,  0.3,  0.3,  0.3,  0.3,  0.0,  0.0,  0.0\r\n    DB  0.3,  0.3,  0.3,  0.5,  0.0, -0.5,  0.0,  0.0\r\n    DB  0.0,  1.5,  1.5,  1.0,  0.3, -0.5, -0.3,  0.0\r\n    DB  0.0,  1.0,  2.3,  1.8,  0.8,  0.3,  0.0,  0.0\r\n    DB  0.3,  0.8,  1.3,  2.3,  1.6,  0.8,  0.5,  0.0\r\n    DB  0.3,  0.5,  1.0,  1.3,  0.5,  0.3,  0.3,  0.0\r\n    DB  0.0,  0.3,  0.3,  0.3,  0.0, -0.3, -0.5,  0.0\r\n    DB  0.0,  0.0,  0.0,  0.0, -0.8, -0.8, -1.0, -0.5\r\n\r\nLight:\r\n    DB 0,   50, -50,  0   // Position\r\n    DB 255, 249, 225, 0.9 // RGB + Intensity\r\n\r\nMATRIX ProjectionMatrix\r\nMATRIX RotateMatrix\r\nMATRIX ViewMatrix\r\n\r\nVEC4F RotateVector, 0,  0,  1,  0  // Rotate around Z axis\r\nVEC4F Perspective,  50, 1,  1,  20 // 2nd value is aspect ratio\r\n\r\nLookAtArgs:\r\n    DB 0,  5,  4 // Camera\r\n    DB 0,  0,  0 // Look at\r\n    DB 0,  0, -1 // Up (terrain is upside-down for some reason)\r\n","gpuchip/examples/foxlogo.txt":"//Fox game console logo (also example on how to work with polygons)\r\n\r\ndclrscr chassis;\r\n\r\ndcolor fox1c;\r\ndvxdata_2f fox1a,16; //16 max!!\r\ndvxdata_2f fox2a,3;\r\ndvxdata_2f fox3a,3;\r\ndvxdata_2f fox4a,3;\r\ndvxdata_2f fox5a,3;\r\ndvxdata_2f fox6a,3;\r\ndvxdata_2f fox7a,6;\r\ndvxdata_2f fox8a,3;\r\n\r\ndcolor fox2c;\r\ndvxdata_2f fox2,4;\r\n\r\ndexit;\r\n\r\n//===========================================\r\ncolor chassis,0,0,0;\r\n\r\ncolor fox1c,60,60,60;\r\ncolor fox2c,100,100,100;\r\n//===========================================\r\nfox1a: //N=16\r\ndb 60,218\r\ndb 62,173\r\ndb 32,36\r\ndb 214,119\r\ndb 268,128\r\ndb 318,168\r\ndb 352,233\r\ndb 494,243\r\ndb 499,254\r\ndb 496,266\r\ndb 478,321\r\ndb 335,374\r\ndb 265,408\r\ndb 223,419\r\ndb 95,430\r\ndb 109,408\r\n\r\nfox2a: //N = 3\r\ndb 109,408\r\ndb 57,432\r\ndb 69,376\r\nfox3a:\r\ndb 69,376\r\ndb 33,394\r\ndb 59,327\r\nfox4a:\r\ndb 59,327\r\ndb 24,348\r\ndb 54,273\r\nfox5a:\r\ndb 54,273\r\ndb 29,286\r\ndb 57,240\r\nfox6a:\r\ndb 57,240\r\ndb 26,245\r\ndb 60,218\r\n\r\nfox7a: //N=6\r\ndb 109,408\r\ndb 69,376\r\ndb 59,327\r\ndb 54,273\r\ndb 57,240\r\ndb 60,218\r\n\r\nfox8a: //N=3\r\ndb 177,150;\r\ndb 269,150;\r\ndb 190,47;\r\n\r\n//===========================================\r\nfox2: //N=4\r\ndb 340,238\r\ndb 286,257\r\ndb 274,203\r\ndb 311,213\r\n//===========================================\r\n","gpuchip/examples/3d_letter_a.txt":"// Author: Drunkie\r\n// Description: Draws a 3D model of the letter A\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nvoid Main()\r\n{\r\n    glSleep( 40 ); // Sleep for 40 milliseconds (reduces fps lag)\r\n    glClear( 100, 149, 237 ); // Clear screen\r\n\r\n    glCoordPipe( GL_CPIPE_N1_1 ); // Set coordinate pipe to [-1 to 1] mode\r\n    glVertexPipe( GL_VPIPE_XYZTRANSFORM ); // Set vertex pipe to xyz transformation\r\n\r\n    glLightPos( 0, 0, -50 ); // Set the light position\r\n    glLightColor( 255, 255, 255, 1 ); // Set the light color\r\n\r\n    glLookAt(\r\n        0, 0, -2.8, // Camera pos\r\n        0, 0, 0, // Camera target\r\n        0, 1, 0 // Camera up\r\n    );\r\n\r\n    // Create variable to hold curtime\r\n    float time;\r\n    timer time;\r\n\r\n    // Create perspective and matrix transformations\r\n    glPerspective( 30, 1, 1, 20 ); // FOV, ASPECT RATIO, ZNEAR, ZFAR\r\n    glRotate( 0, 1, 0, time ); // AXIS X, Y, Z, ANGLE W\r\n    glTranslate( 0, -0.1, 0, 0 ); // TRANSLATION X, Y, Z\r\n    glScale( 1, 1, 1, 0 ); // SCALE X, Y, Z\r\n\r\n    glEnable( GL_VERTEX_BUFFER ); // Enable vertex buffer\r\n    glEnable( GL_VERTEX_ZSORT ); // Enable Z sorting\r\n    glEnable( GL_VERTEX_LIGHTING ); // Enable vertex lighting\r\n    glEnable( GL_VERTEX_CULLING ); // Enable face culling\r\n\r\n    // Solid 3D polygon\r\n    glFillMode( GL_FILL_SOLID ); // Set fillmode as solid\r\n    glColor4( 255, 255, 255, 255 ); // Set draw color with alpha\r\n    glPoly3D( vertexBuffer, 30 ); // Draw 3D polygon\r\n    glFlush(); // Flush the vertex buffer to the screen\r\n\r\n    glExit(); // Exit\r\n}\r\n\r\n// The vertex data for our model\r\nvertexBuffer:\r\ndb 1,1,0; db 0.75,1,0; db 0.25,-1,0;\r\ndb 0.75,1,0; db 0,-1,0; db 0.25,-1,0;\r\ndb -1,1,0; db -0.25,-1,0; db -0.75,1,0;\r\ndb -0.75,1,0; db -0.25,-1,0; db 0,-1,0;\r\ndb 1,1,0.25; db 0.25,-1,0.25; db 0.75,1,0.25;\r\ndb 0.75,1,0.25; db 0.25,-1,0.25; db 0,-1,0.25;\r\ndb -1,1,0.25; db -0.75,1,0.25; db -0.25,-1,0.25;\r\ndb -0.75,1,0.25; db 0,-1,0.25; db -0.25,-1,0.25;\r\ndb 0.25,-1,0; db -0.25,-1,0; db 0.25,-1,0.25;\r\ndb -0.25,-1,0; db -0.25,-1,0.25; db 0.25,-1,0.25;\r\ndb -1,1,0; db -1,1,0.25; db -0.25,-1,0;\r\ndb -1,1,0.25; db -0.25,-1,0.25; db -0.25,-1,0;\r\ndb 1,1,0.25; db 1,1,0; db 0.25,-1,0;\r\ndb 1,1,0.25; db 0.25,-1,0; db 0.25,-1,0.25;\r\ndb -0.75,1,0; db 0,-1,0; db -0.75,1,0.25;\r\ndb -0.75,1,0.25; db 0,-1,0; db 0,-1,0.25;\r\ndb 0.75,1,0; db 0.75,1,0.25; db 0,-1,0;\r\ndb 0.75,1,0.25; db 0,-1,0.25; db 0,-1,0;\r\ndb -0.47,0.25,0; db -0.38,0.01,0; db 0.38,0.01,0;\r\ndb 0.38,0.01,0; db 0.47,0.25,0; db -0.47,0.25,0;\r\ndb -0.47,0.25,0.25; db 0.38,0.01,0.25; db -0.38,0.01,0.25;\r\ndb 0.38,0.01,0.25; db -0.47,0.25,0.25; db 0.47,0.25,0.25;\r\ndb -0.38,0.01,0; db -0.38,0.01,0.25; db 0.38,0.01,0;\r\ndb 0.38,0.01,0; db -0.38,0.01,0.25; db 0.38,0.01,0.25;\r\ndb -0.47,0.25,0; db 0.47,0.25,0; db -0.47,0.25,0.25;\r\ndb -0.47,0.25,0.25; db 0.47,0.25,0; db 0.47,0.25,0.25;\r\ndb -1,1,0; db -0.75,1,0; db -1,1,0.25;\r\ndb -0.75,1,0; db -0.75,1,0.25; db -1,1,0.25;\r\ndb 1,1,0; db 1,1,0.25; db 0.75,1,0;\r\ndb 0.75,1,0; db 1,1,0.25; db 0.75,1,0.25;\r\n","gpuchip/examples/3d_tunnel.txt":"// Author: Drunkie\r\n// Description: Draws a never ending tunnel in 3D!\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nvoid Main()\r\n{\r\n    glSleep( 60 ); // Sleep for 60 milliseconds (reduces fps lag)\r\n    glClear( 0, 0, 0 ); // Clear screen\r\n\r\n    glCoordPipe( GL_CPIPE_N1_1 ); // Set coordinate pipe to [-1 to 1] mode\r\n    glVertexPipe( GL_VPIPE_XYZTRANSFORM ); // Set vertex pipe to xyz transformation\r\n\r\n    glLightPos( -1, -1, -1 ); // Set the light position\r\n    glLightColor( 255, 255, 255, 1.25 ); // Set the light color\r\n\r\n    glLookAt(\r\n        0, 0, -25, // Camera pos\r\n        0, 0, 0, // Camera target\r\n        0, 1, 0 // Camera up\r\n    );\r\n\r\n    // Loop and draw 4 models\r\n    for (i = 0; i < 4; i++)\r\n    {\r\n        // Set translations for each model\r\n        timer zTranslate;\r\n        zTranslate *= -16;\r\n        mod zTranslate,16;\r\n        zTranslate += (i * 16);\r\n\r\n        // Create perspective and matrix transformations\r\n        glPerspective( 8, 1, 0.4, 20 ); // FOV, ASPECT RATIO, ZNEAR, ZFAR\r\n        glRotate( 0, 0, 0, 0 ); // AXIS X, Y, Z, ANGLE W\r\n        glTranslate( 0, 0, zTranslate ); // TRANSLATION X, Y, Z\r\n        glScale( 1.2, 1, 8 ); // SCALE X, Y, Z\r\n\r\n        glEnable( GL_VERTEX_BUFFER ); // Enable vertex buffer\r\n        glEnable( GL_VERTEX_ZSORT ); // Enable Z sorting\r\n        glEnable( GL_VERTEX_LIGHTING ); // Enable vertex lighting\r\n        glEnable( GL_VERTEX_CULLING ); // Enable face culling\r\n\r\n        // Solid 3D polygon\r\n        glFillMode( GL_FILL_SOLID ); // Set fillmode as solid\r\n        glColor4( 255, 255, 255, 150 ); // Set the draw color with alpha\r\n        glPoly3D( VertexBuffer, 12 ); // Draw 3D polygon\r\n        glFlush(); // Send our vertex buffer to screen\r\n\r\n        // Wireframe 3D polygon\r\n        glLineWidth( 1 ); // Set line width of wireframe\r\n        glFillMode( GL_FILL_WIREFRAME ); // Set fillmode to wireframe\r\n        glColor4( 255, 255, 255, 255 ); // Set the draw color with alpha\r\n        glPoly3D( vertexBuffer, 8 ); // Draw 3D polygon\r\n        glFlush(); // Send our vertex buffer to screen\r\n    }\r\n\r\n    glExit(); // Exit\r\n}\r\n\r\nfloat i;\r\nfloat zTranslate;\r\n\r\nvertexBuffer:\r\ndb 1,1,-1; db -1,1,-1; db 1,1,1;\r\ndb -1,1,-1; db -1,1,1; db 1,1,1;\r\ndb 1,1,-1; db 1,1,1; db 1,-1,-1;\r\ndb 1,-1,-1; db 1,1,1; db 1,-1,1;\r\ndb -1,1,-1; db -1,-1,-1; db -1,1,1;\r\ndb -1,-1,-1; db -1,-1,1; db -1,1,1;\r\ndb 1,-1,-1; db 1,-1,1; db -1,-1,-1;\r\ndb -1,-1,-1; db 1,-1,1; db -1,-1,1;\r\n","gpuchip/examples/hud_engine.txt":"//mov #65522,1;\r\n//mov #65525,0.66;\r\n//port0 & port1 - engine left/right throttle (0..1)\r\n//port2 & port3 - delta (not used)\r\n\r\n//This displays engine window in PhoenixWings airplane\r\n\r\nmov #65485,16; //set circle quality\r\n\r\ndclrscr hud_border;\r\n\r\ndcolor hud_text;\r\ndcircle hud_engine1gauge,68;\r\ndcircle hud_engine2gauge,68;\r\ndcolor hud_border;\r\ndcircle hud_engine1gauge,64;\r\ndcircle hud_engine2gauge,64;\r\n\r\ndcolor hud_text;\r\ndsetwidth 1;\r\ndline hud_engine1gauge_start,hud_engine1gauge;\r\ndline hud_engine2gauge_start,hud_engine2gauge;\r\n\r\ndsetwidth 2;\r\n\r\n//===\r\nmov eax,port0; mul eax,100;\r\nmul eax,0.1;\r\nmul #left_power,1.9;\r\nadd #left_power,eax;\r\ndiv #left_power,2;\r\n\r\nmov eax,#left_power; div eax,100;\r\nmul eax,6.00;\r\nadd eax,1.57;\r\n\r\ndrotatescale eax,1;\r\ndmove hud_engine1gauge;\r\n\r\ndline gauge_base,gauge_needle;\r\n//==\r\nmov #right_power,#left_power; //comment this and..\r\n//uncomment if your left/right engines are not synchronized\r\n//mov eax,port1; mul eax,100;\r\n//mul eax,0.1;\r\n//mul #right_power,1.9;\r\n//add #right_power,eax;\r\n//div #right_power,2;\r\n\r\n//mov eax,#right_power; div eax,100;\r\n//mul eax,6.00;\r\n//add eax,1.57;\r\n\r\ndrotatescale eax,1;\r\ndmove hud_engine2gauge;\r\n\r\ndline gauge_base,gauge_needle;\r\n//==\r\n\r\n//use this for whatever you wanna\r\n//mov #left_delta,port2; sub #left_delta,7.6; mul #left_delta,10;\r\n//mov #right_delta,port3; sub #right_delta,7.6; mul #right_delta,10;\r\n\r\ndrotatescale 0,1; //reset!\r\ndmove 0;\r\n\r\ndsetfont 4;\r\ndsetsize 28;\r\ndwritefmt hud_text1pos,hud_text1;\r\ndwritefmt hud_text2pos,hud_text2;\r\n\r\ncmp port4,1;\r\ndcolor hud_yellow;\r\nje _nsh;\r\n  dshade 0.25;\r\n_nsh:\r\ndwrite hud_text3pos,hud_text3;\r\ndexit;\r\n\r\nvector2f hud_text1pos,70,212;\r\nvector2f hud_text2pos,310,212;\r\nvector2f hud_text3pos,20,460;\r\n\r\nstring hud_text1,'Left Engine',10,10,'N1 = %i%%',10,'Delta = %i%%';\r\nalloc left_power; alloc left_delta;\r\nstring hud_text2,'Right Engine',10,10,'N1 = %i%%',10,'Delta = %i%%';\r\nalloc right_power; alloc right_delta;\r\nstring hud_text3,'<FASTEN SEAT BELTS>';\r\n\r\nvector2f hud_engine1gauge,128,128;\r\nvector2f hud_engine1gauge_start,128,64;\r\n\r\nvector2f hud_engine2gauge,384,128;\r\nvector2f hud_engine2gauge_start,384,64;\r\n\r\nvector2f gauge_base,0,0;\r\nvector2f gauge_needle,0,-48;\r\n\r\ncolor hud_text,64,255,64;\r\ncolor hud_yellow,255,255,64;\r\ncolor hud_border,30,30,30;\r\n","gpuchip/examples/table.txt":"// Author: Drunkie\r\n// Description: Draws a table; useful for calendars or spreadsheets!\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nfloat rows = 6;\r\nfloat cols = 5;\r\nfloat sizex = 476;\r\nfloat sizey = 400;\r\nfloat linewidth = 3;\r\n\r\nfloat i, j, day;\r\n\r\nvoid Main()\r\n{\r\n    dentrypoint 0,DrawThread;\r\n    dentrypoint 4,AsyncThread;\r\n\r\n    *regHWClear = 0\r\n    *regAsyncFreq = 200000;\r\n    *regAsyncClk = 1;\r\n}\r\n\r\nvoid DrawThread()\r\n{\r\n    dexit;\r\n}\r\n\r\nvoid AsyncThread()\r\n{\r\n    glBegin();\r\n\r\n        glClear( 35, 35, 35 ); // Clear screen color\r\n\r\n        glColor( 255, 255, 255 ); // Set draw color\r\n        glFont( GL_FONT_ARIAL ); // Set font type\r\n        glFontSize( 36 ); // Set font size\r\n        glWriteString( 16, 6, 'Simple-Calendar 1.0');\r\n\r\n        glColor( 120, 120, 120 );\r\n        glOffset( 16, 64 ); // Set screen offset\r\n        glRectWH( 0, 0, sizex + linewidth, sizey + linewidth); // Draw rectangle\r\n\r\n        glFont( GL_FONT_TREBUCHET );\r\n        glFontSize( 14 );\r\n\r\n        // Calculate rectangle size\r\n        float sx = (sizex / rows) - linewidth;\r\n        float sy = (sizey / cols) - linewidth;\r\n\r\n        // Loop through rows\r\n        for (i = 0; i < rows; i++)\r\n        {\r\n            // Loop through columns\r\n            for (j = 0; j < cols; j++)\r\n            {\r\n                // Calculate x,y coordinate to draw at\r\n                float x = i * (sizex / rows);\r\n                float y = j * (sizey / cols);\r\n\r\n                glColor( 200, 200, 200 ); // Set draw color\r\n                glRectWH( x + linewidth, y + linewidth, sx, sy ); // Draw rectangle\r\n\r\n                glColor( 0, 0, 0 ); // Set draw color\r\n\r\n                // Write integer to screen\r\n                day = i + (j * rows)\r\n                glWriteInt( x + linewidth + 2, y + linewidth + 2, day + 1 );\r\n            }\r\n        }\r\n\r\n    glEnd();\r\n}\r\n","gpuchip/examples/3d_cube.txt":"// Author: Drunkie\r\n// Description: 3D Cube\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nvoid Main()\r\n{\r\n    glClear( 0, 0, 0 ); // Clear screen\r\n\r\n    glCoordPipe( GL_CPIPE_N1_1 ); // Set coordinate pipe to [-1 to 1] mode\r\n    glVertexPipe( GL_VPIPE_XYZTRANSFORM ); // Set vertex pipe to xyz transformation\r\n\r\n    glLightPos( 0, 0, -20 ); // Set the light position\r\n    glLightColor( 255, 255, 255, 1 ); // Set the light color\r\n\r\n    glLookAt(\r\n        0, 0, -5, // Camera pos\r\n        0, 0, 0, // Camera target\r\n        0, 1, 0 // Camera up\r\n    );\r\n\r\n    // Create variable to hold curtime\r\n    float time;\r\n    timer time;\r\n\r\n    // Create perspective and matrix transformations\r\n    glPerspective( 30, 1, 1, 20 ); // FOV, ASPECT RATIO, ZNEAR, ZFAR\r\n    glRotate( 1, 1, 0, time ); // AXIS X, Y, Z, ANGLE W\r\n    glTranslate( 0, 0, 0 ); // TRANSLATION X, Y, Z\r\n    glScale( 1, 1, 1 ); // SCALE X, Y, Z\r\n\r\n    glEnable( GL_VERTEX_BUFFER ); // Enable vertex buffer\r\n    glEnable( GL_VERTEX_ZSORT ); // Enable Z sorting\r\n\r\n    // Solid 3D polygon\r\n    glFillMode( GL_FILL_SOLID ); // Set fillmode as solid\r\n    glColor4( 100, 149, 237, 180 ); // Set draw color with alpha\r\n    glPoly3D( vertexBuffer, 12 ); // Draw 3D polygon\r\n    glFlush(); // Flush the vertex buffer to the screen\r\n\r\n    // Wireframe 3D polygon\r\n    glLineWidth( 1 ); // Set line width\r\n    glFillMode( GL_FILL_WIREFRAME ); // Set fillmode as solid\r\n    glColor4( 255, 255, 255, 255 ); // Set draw color with alpha\r\n    glPoly3D( vertexBuffer, 12 ); // Draw 3D polygon\r\n    glFlush(); // Flush the vertex buffer to the screen\r\n\r\n    glExit(); // Exit\r\n}\r\n\r\n// The vertex data for our model\r\nvertexBuffer:\r\ndb -1,-1,-1; db 1,-1,-1; db 1,1,-1;\r\ndb -1,-1,-1; db 1,1,-1; db -1,1,-1;\r\ndb 1,-1,1; db -1,-1,1; db 1,1,1;\r\ndb -1,-1,1; db -1,1,1; db 1,1,1;\r\ndb 1,-1,-1; db -1,-1,-1; db 1,-1,1;\r\ndb -1,-1,-1; db -1,-1,1; db 1,-1,1;\r\ndb -1,1,-1; db 1,1,-1; db 1,1,1;\r\ndb -1,1,1; db -1,1,-1; db 1,1,1;\r\ndb -1,-1,-1; db -1,1,-1; db -1,1,1;\r\ndb -1,-1,1; db -1,-1,-1; db -1,1,1;\r\ndb 1,1,-1; db 1,-1,-1; db 1,1,1;\r\ndb 1,-1,-1; db 1,-1,1; db 1,1,1;\r\n","gpuchip/examples/hud_fighter.txt":"//Aircraft hud\r\n//port0 - ROLL\r\n//port1 - PITCH\r\n//port2 - YAW (heading)\r\n//port3 - speed (units/sec)\r\n//port4 - altitude (units)\r\n//port5 - radar altitude (put ranger under your plane, and attach to this)\r\n//port6 - flaps active, 1 or 0\r\n//port7 - go to \"Gates - Time\", and find \"Derivative\". Attach this to derivative, and derivative to altitude (vertical speed)\r\n\r\n//Artiftical horizon\r\nin eax,0; //Roll\r\nin ebx,1; //Pitch\r\n\r\n//mul ebx,0.017453292;\r\nmul eax,0.017453292;\r\nadd eax,1.57;\r\n\r\ndiv ebx,90;\r\nmul ebx,512;\r\nadd ebx,256;\r\n\r\nmov #horizon_moveoffset.y,ebx;\r\n\r\ndrotatescale eax,1;\r\ndmove horizon_moveoffset;\r\n\r\ndcolor art_sky;\r\ndrectwh horizon_sky_offset,horizon_size;\r\ndcolor art_grnd;\r\ndrectwh horizon_grnd_offset,horizon_size;\r\n\r\ndcolor hud_text;\r\ndsetsize 20;\r\nmov eax,-45;\r\n_horizon_text:\r\n  mov ebx,eax;\r\n  mul ebx,5.68;\r\n  sub ebx,10;\r\n  mov #horizon_textpos1.y,ebx;\r\n  mov #horizon_textpos2.y,ebx; add ebx,9;\r\n  mov #horizon_rectpos1.y,ebx; add ebx,2;\r\n  mov #horizon_rectpos2.y,ebx;\r\n\r\n  drect horizon_rectpos1,horizon_rectpos2;\r\n  dwritei horizon_textpos1,eax;\r\n  dwritei horizon_textpos2,eax;\r\n\r\n  add eax,15;\r\n  cmp eax,45;\r\n  jle _horizon_text;\r\n\r\n//Reset\r\ndmove 0;\r\ndrotatescale 0,1;\r\n\r\n//Border around art horizon\r\ndcolor border_color;\r\ndrect border_p1,border_p2;\r\ndrect border_p3,border_p4;\r\ndrect border_p5,border_p6;\r\ndrect border_p7,border_p8;\r\ndcolor border_color2;\r\ndrect border_p9,border_p10;\r\n\r\n//Draw hud stuff\r\nmov #roll,port0;\r\nmov #pitch,port1;\r\nmov #hdg,port2; add #hdg,180;\r\nmov #spd,port3; div #spd,17.6;\r\nmov #alt,port4;\r\nadd #alt,12000;\r\ndiv #alt,12;\r\nmov #ralt,port5; div #ralt,12;\r\nmov #vspd,port7; div #vspd,17.6;\r\ndcolor hud_text;\r\ndwritefmt hud_pos1,hud_text1;\r\ndsetsize 16;\r\ndwritefmt hud_pos2,hud_text2;\r\n\r\ndcolor hud_text;\r\nmov eax,port6; mul eax,0.75; add eax,0.25;\r\ndshade eax;\r\ndwritefmt hud_pos3,hud_text3;\r\n\r\n\r\ndexit;\r\n\r\nvec2f hud_pos1,50,20;\r\nstring hud_text1,'ROLL %i %tPITCH %i%tHDG %i';\r\nalloc roll;\r\nalloc pitch;\r\nalloc hdg;\r\n\r\nvec2f hud_pos2,45,120;\r\nstring hud_text2,'SPD',10,'%ikt',10,10,'ALT',10,'%ift',10,10,'RALT',10,'%ift',10,10,'VSPD',10,'%ift/s';\r\nalloc spd;\r\nalloc alt;\r\nalloc ralt;\r\nalloc vspd;\r\n\r\nvec2f hud_pos3,45,400;\r\nstring hud_text3,'FLAPS';\r\n\r\n\r\nvec2f horizon_textpos1,96,0;\r\nvec2f horizon_textpos2,-64,0;\r\nvec2f horizon_rectpos1,-50,0;\r\nvec2f horizon_rectpos2,50,0;\r\ncolor hud_text,64,255,64;\r\n\r\ncolor border_color2,255,255,255;\r\ncolor border_color,30,30,30;\r\nvec2f border_p1,0,0;\r\nvec2f border_p2,128,512;\r\nvec2f border_p3,384,0;\r\nvec2f border_p4,512,512;\r\n\r\nvec2f border_p5,128,0;\r\nvec2f border_p6,384,64;\r\nvec2f border_p7,128,448;\r\nvec2f border_p8,384,512;\r\n\r\nvec2f border_p9,128,254;\r\nvec2f border_p10,384,258;\r\n\r\nvec2f horizon_sky_offset,-256,-512;\r\nvec2f horizon_grnd_offset,-256,0;\r\nvec2f horizon_size,512,512;\r\n\r\nvec2f horizon_moveoffset,256,256;\r\n\r\ncolor art_sky,24,144,255;\r\ncolor art_grnd,192,72,0;\r\n","gpuchip/examples/line_graph.txt":"// Author: Drunkie\r\n// Description: A fake lag-o-meter that plots points on a grid\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nfloat i;\r\nfloat x, y;\r\nfloat ox = 0, oy = 256;\r\nfloat lines = 10;\r\nfloat lineWidth = 1\r\nfloat frameWidth = 510;\r\nfloat frameHeight = 300;\r\n\r\nvoid Main()\r\n{\r\n    glVertexMode( 1 ); // Enable vertex mode\r\n    glColor( 255, 255, 255 ); // Set draw color\r\n\r\n    // Set texture as background\r\n    glBindTexture( \"phoenix_storms/lag_sign\" );\r\n    glClearTexture();\r\n    glBindTexture( 0 ); // Discard texture\r\n\r\n    glFont( GL_FONT_AKBAR ); // Set font type\r\n    glFontSize( 36 ); // Set font size\r\n    glWriteString( 2, 2, \"LAG-O-METER\" ); // Write string to screen\r\n\r\n    glOffset( lineWidth, 90 ); // Offset the screen coordinates\r\n\r\n    glColor4( 0, 0, 0, 160 ); // Set draw color with alpha\r\n    glRectWH( 0, 0, frameWidth, frameHeight ); // Draw rectangle\r\n\r\n    glColor( 255, 255, 255 );\r\n    glLineWidth( lineWidth ); // Set line width\r\n    glORectWH( 0, 0, frameWidth, frameHeight ); // Draw outlined rectangle\r\n\r\n    glLineWidth( 1 ); // Set line width to 1\r\n\r\n    // Loop and make a bunch of connected lines\r\n    for (i = 0; i < lines; i++)\r\n    {\r\n        if (i == 0) {\r\n            ox = 0;\r\n            rand oy;\r\n            oy *= frameHeight;\r\n        }\r\n        else {\r\n            ox = x; oy = y;\r\n        }\r\n        x = ((i+1) / lines) * frameWidth;\r\n        rand y;\r\n        y *= frameHeight;\r\n        glLine( ox, oy, x, y ); // Draw line on graph\r\n    }\r\n\r\n    glOffset( 0, 0 ); // Set screen offset back to 0,0\r\n    glWriteString( 2, 400, \"INTENSE LAG DETECTED\" );\r\n\r\n    glExit(); // Exit\r\n}\r\n","gpuchip/examples/mt2.txt":"dcvxpipe 3;\r\nmov #regHWClear,0; //Stop hardware clearing\r\ndsetwidth 0.05;\r\n\r\ntimer EAX;\r\nmov EDX,EAX; sub EDX,#PrevTime; //EDX = Delta time\r\nmov #PrevTime,EAX;\r\n\r\nmov EBP,0.4; //Speed of rotation\r\n\r\nmov ECX,8;\r\nDrawLoop:\r\n  mov EAX,#Angle; mul EAX,1;\r\n  fsin #EndPoint.X,EAX; mul EAX,2;\r\n  fcos #EndPoint.Y,EAX;\r\n\r\n  //HSL coloring\r\n  fsin #HSL.R,EAX; mul #HSL.R,127; add #HSL.R,128; add EAX,1.57;// mul EAX,2;\r\n  fsin #HSL.G,EAX; mul #HSL.G,127; add #HSL.G,128; add EAX,1.57;// mul EAX,2;\r\n  fsin #HSL.B,EAX; mul #HSL.B,127; add #HSL.B,128;\r\n\r\n  dcolor HSL;\r\n\r\n  //Looks very nice\r\n  dline StartPoint1,EndPoint;\r\n  dline StartPoint2,EndPoint;\r\n  dline StartPoint3,EndPoint;\r\n  dline StartPoint4,EndPoint;\r\n\r\n  mul EDX,EBP;\r\n  add #Angle,EDX;\r\nloop DrawLoop;\r\n\r\ndexit;\r\n\r\nalloc Angle;\r\nalloc PrevTime;\r\n\r\ncolor HSL;\r\n\r\nvector2f EndPoint,0,0;\r\nvector2f StartPoint0,0,0;\r\nvector2f StartPoint1,1,1;\r\nvector2f StartPoint2,1,-1;\r\nvector2f StartPoint3,-1,-1;\r\nvector2f StartPoint4,-1,1;\r\n","gpuchip/examples/bounce.txt":"//////////////////////////////////\r\n//  BOUNCING BALL GPU EXAMPLE   //\r\n//////////////////////////////////\r\ndentrypoint 0,_draw;\t\t// Set draw start entrypoint to \"_draw\"\r\n\t\t\t\t//\r\nrand #ball.x;\t\t\t// Set random ball start point\r\nrand #ball.y;\t\t\t//\r\n\t\t\t\t//\r\ndexit;\t\t\t\t// Exit the initialization routine...\r\n//////////////////////////////////\r\n_draw:\t\t\t\t// Entrypoint for the drawing function\r\n\t\t\t\t//\r\ndcvxpipe 2;\t\t\t// Set coordinate pipe to 2 (to use coordinates 0...1)\r\ndclrscr bg_color;\t\t// Clear screen with background color\r\n\t\t\t\t//\r\ndmuldt eax,#d.x;\t\t// EAX = Direction Vector * Delta (change of coords per frame)\r\nadd #ball.x,eax;\t\t// Move the ball\r\ndmuldt eax,#d.y;\t\t//\r\nadd #ball.y,eax;\t\t//\r\n\t\t\t\t//\r\ncmp #ball.x,0.9;\t\t// Check hits against walls\r\ncge bounce.x;\t\t\t// Call bounce routine...\r\ncmp #ball.x,0.0;\t\t//\r\ncle bounce.x;\t\t\t//\r\n\t\t\t\t//\r\ncmp #ball.y,0.9;\t\t// Bounce on other axis\r\ncge bounce.y;\t\t\t//\r\ncmp #ball.y,0.0;\t\t//\r\ncle bounce.y;\t\t\t//\r\n\t\t\t\t//\r\ndcolor ball_color;\t\t// Set color to color of ball\r\ndrectwh ball,ball_wh;\t\t// Draw the ball\r\n\t\t\t\t//\r\ndsetsize 24;\t\t\t// Set font size\r\ndwrite textpos,text;\r\n\t\t\t\t//\r\ndexit;\t\t\t\t// Exit the draw function\r\n//////////////////////////////////\r\nbounce.x:\t\t\t// Bounce function (change X speed)\r\n  neg #d.x; \t\t\t//\r\n  min #ball.x,0.9;\t\t//\r\n  max #ball.x,0.0;\t\t//\r\nret\t\t\t\t//\r\n\t\t\t\t//\r\nbounce.y:\t\t\t// Bounce function (change Y speed)\r\n  neg #d.y;\t\t\t//\r\n  min #ball.y,0.9;\t\t//\r\n  max #ball.y,0.0;\t\t//\r\nret\t\t\t\t//\r\n//////////////////////////////////\r\n// Data and resources\t\t//\r\n//////////////////////////////////\r\n\t\t\t\t//\r\ncolor ball_color,255,255,255;\t// Ball color (white)\r\ncolor bg_color,   64, 32,128;\t// Background color (neon violet)\r\n\t\t\t\t//\r\nvector2f ball;\t\t\t// Ball position\r\nvector2f ball_wh,0.1,0.1;\t// Ball width/height\r\n\t\t\t\t//\r\nvector2f textpos,0.1,0.1;\t// Text position\r\n\t\t\t\t//\r\nvector2f d,1.0,1.0;\t\t// Movement direction & speed\r\n\t\t\t\t//\r\nstring text,'Bouncing ball!';\t// \"Bouncing ball!\"\r\n//////////////////////////////////\r\n","gpuchip/examples/plasma.txt":"//Plasma fractals\r\n//Converted by dlb from http://bocoup.com/processing-js/docs/index.php?page=Plasma%20Fractals\r\n//Which was converted by F1LT3R @ Hyper-Metrix.com from original at http://www.ic.sunysb.edu/Stu/jseyster/plasma/\r\n\r\nmov #regHWClear,0; //Stop GPU clearing itself\r\n\r\ndentrypoint 0,_draw; //Set the entry point for the draw loop\r\ndentrypoint 4,_async; //Set the enty point for the async loop\r\n\r\nmov #regAsyncFreq,2000000; //Make async run as fast as it can\r\nmov #regAsyncClk,1; //Start async\r\n\r\ndexit; //End init\r\n_draw: //Start draw\r\ndexit; //End draw\r\n\r\n//Setup variables\r\ncolor col;\r\nvec2f pos;\r\nvec2f size;\r\nfloat gridSize, edge1, edge2, edge3, edge4, midPoint, newWidth, newHeight, width, height, noise;\r\n\r\n_async: //Enter async\r\n\r\nmain(); //Run main function\r\n\r\nwhile(1){idle} //Infinatly loop\r\n\r\nvoid main(){ //Main function\r\n    dsetbuf_spr; //Use sprite buffer\r\n\r\n    setColor(255,255,255); //Set the colour to white\r\n    rect(0,0,512,512); //Draw a large rectangle\r\n\r\n    gridSize = 4; //How big each rectangle will be\r\n    width = 512; //GPU Width\r\n    height = 512; //GPU Height\r\n    noise = 5; //How noisy it will be\r\n\r\n    //Give initial corner values\r\n    R1 = random(1);\r\n    R2 = random(1);\r\n    R3 = random(1);\r\n    R4 = random(1);\r\n\r\n    plasma(0,0,width,height,R1,R2,R3,R4) //Start recursive function\r\n}\r\n\r\nvoid plasma(float x, y, width, height, c1, c2, c3, c4){ //Plasma function\r\n\r\n    //Setup local variables\r\n    float edge1, edge2, edge3, edge4, midPoint;\r\n\r\n    //Work out the size of the next segments\r\n    float newWidth = width / 2;\r\n    float newHeight = height / 2;\r\n\r\n    if((width > gridSize)||(height > gridSize)){ //If it is still bigger than the rectangle size\r\n\r\n        midPoint = (c1 + c2 + c3 + c4) / 4 + displace(newWidth + newHeight); //Randomly change the midpoint\r\n\r\n        //Calculate edges by averaging the corners\r\n        edge1 = (c1 + c2) / 2;\r\n        edge2 = (c2 + c3) / 2;\r\n        edge3 = (c3 + c4) / 2;\r\n        edge4 = (c4 + c1) / 2;\r\n\r\n        //Make sure it doesn't displace too far\r\n        max midPoint,0;\r\n        min midPoint,1;\r\n\r\n        //Run on the newly calculated segments\r\n        plasma(x, y, newWidth, newHeight, c1, edge1, midPoint, edge4);\r\n        plasma(x + newWidth, y, newWidth, newHeight, edge1, c2, edge2, midPoint);\r\n        plasma(x + newWidth, y + newHeight, newWidth, newHeight, midPoint, edge2, c3, edge3);\r\n        plasma(x, y + newHeight, newWidth, newHeight, edge4, midPoint, edge3, c4);\r\n    }else{ //Woo! It's the right size\r\n        float c = (c1 + c2 + c3 + c4) / 4; //Average the corners\r\n\r\n        float grey = c*255; //Multiply the corners by 255 to get a valid color\r\n\r\n        setColor(grey,grey,grey); //Set the color to your new color based on the \"height\"\r\n        rect(x,y,gridSize,gridSize); //Draw your rectangle\r\n    }\r\n}\r\n\r\nfloat displace(float num){ //Displace function, it just works\r\n    float m = num / (width + height) * (1/noise);\r\n    R1 = random(1);\r\n    return (R1-0.5) * m;\r\n}\r\n\r\nfloat random(float x){ //C version of the ASM rand opcode\r\n    preserve EAX;\r\n    rand EAX;\r\n    return EAX*x;\r\n}\r\n\r\nvoid setColor(float r,float g,float b){ //C version of the dcolor opcode\r\n    mov #col.r,r;\r\n    mov #col.g,g;\r\n    mov #col.b,b;\r\n\r\n    dcolor col;\r\n}\r\n\r\nvoid rect(float x, float y, float width, float height){ //C version of the drectwh opcode\r\n    mov #pos.x,x;\r\n    mov #pos.y,y;\r\n\r\n    mov #size.x,width;\r\n    mov #size.y,height;\r\n\r\n    drectwh pos, size;\r\n    dswap; //dswap to make it show since we're drawing to the sprite buffer\r\n}\r\n","gpuchip/examples/stargate.txt":"//STARGATE DIAL COMPUTER MAIN DISPLAY (realistic colors)\r\n//\r\n//How to connect:\r\n//GPU IOBus to Data Port\r\n//Port0 to \"Open\"\r\n//Port1 to \"Active\"\r\n//Port2 to \"Chevron\"\r\n//Port3 to \"Inbound\"\r\n//Port4 to iris\r\n//\r\n//That's all!\r\n\r\ndiv #65525,1.33;\r\nmov #65485,16; //65485 is the circle quality register\r\n\r\n//24 means circles have 24 sides\r\n//You can have up to 128 sides, but that LAGS\r\n//32 sides is not even noticable comparing to 128\r\n\r\n//= Misc decorations ==================\r\n\r\ndcolor stargate_out_ring;\r\ndcircle center,250;\r\ndcolor stargate_middle_ring;\r\ndcircle center,240;\r\ndcolor stargate_out_ring;\r\ndcircle center,223;\r\n\r\n//= Rotating ring =====================\r\nmov #65485,12;\r\ndcolor stargate_inner_ring;\r\n\r\nin ecx,2; //This block checks if chevron 7 is engaged\r\ncmp ecx,7; //If yes, dont spin\r\nmov eax,0;\r\njge _norotate;\r\n  timer eax;\r\n_norotate:\r\n\r\nin ebx,1; //This one checks if stargate is active\r\nmul eax,ebx;\r\n\r\nin ebx,3; neg ebx; add ebx,1; //This one checks if its inbound\r\nmul eax,ebx; //wormhole\r\n\r\ndrotatescale eax,1; //rotate by EAX radians\r\ndmove center;\r\ndcircle 0,220;\r\n\r\ndrotatescale 0,1; //Reset scale/movment\r\ndmove 0;\r\n\r\n//= Inner ring around EH ==============\r\nmov #65485,24;\r\ndcolor stargate_out_ring;\r\ndcircle center,190;\r\n\r\n\r\n//= EH ================================\r\ndcolor black;\r\ndcircle center,180; //draw black hole instead of event horizon\r\n\r\ndcolor stargate_eventhorizon;\r\n\r\nin ebx,0; //Stargate active?\r\ncmp ebx,0;\r\nmov eax,0;\r\nje _active;\r\n  rand eax;\r\n  mul eax,0.1;\r\n  add eax,0.9;\r\n_active:\r\n\r\nin ebx,0; mul ebx,180;\r\n\r\nmul #eventhorizon_radius,0.99;\r\nmul ebx,1.01;\r\nadd #eventhorizon_radius,ebx;\r\ndiv #eventhorizon_radius,2;\r\n\r\n\r\ndshade eax;\r\ndcircle center,#eventhorizon_radius;\r\n\r\n//= Iris ==============================\r\nmov edx,port4;\r\nneg edx; add edx,1;\r\n\r\nmov eax,#iris_status;\r\nsub eax,edx;\r\nfabs eax,eax;\r\n\r\ndmuldt ecx,8;\r\n\r\ncmp eax,0.02;\r\njl _donothing;\r\n  cmp #iris_status,edx;\r\n  jl _lower;\r\n    sub #iris_status,ecx;\r\n  jmp _donothing;\r\n  _lower:\r\n    add #iris_status,ecx;\r\n_donothing:\r\n\r\nmov #iris1.y,#iris_status;\r\nmul #iris1.y,#iris2.y;\r\n\r\ndmove center;\r\n\r\nmov ecx,12;\r\n_iris:\r\n  fsin ebx,ecx; fabs ebx,ebx; div ebx,10; add ebx,0.7;\r\n\r\n  mov eax,ecx; mul eax,0.490; add eax,0.01; //0.697\r\n  add eax,#iris_status;\r\n\r\n  drotatescale eax,1;\r\n\r\n  dcolor iris_color;\r\n  dshade ebx;\r\n\r\n  drect iris1,iris2;\r\nloop _iris;\r\n\r\ndmove 0;\r\n\r\n//= Chevrons ==========================\r\nmov eax,1; //Chevron ID\r\nin ebx,2;\r\ndmove center;\r\n_chevron_loop:\r\n  mov edx,eax; //Compute chevron angle in radians\r\n  mul edx,0.69815;\r\n  sub edx,1.23333;\r\n\r\n  drotatescale edx,1; //Rotate chevron polygon\r\n  dcolor stargate_chevron;\r\n\r\n  mov edx,eax:#chevron_triggers;\r\n\r\n  cmp edx,ebx; //Check if chevron is light up\r\n  jle _noshade;\r\n    dshade 0.25;\r\n  _noshade:\r\n\r\n  dvxpoly chevron_polygon,4; //draw chevron polygon\r\n\r\n  inc eax;\r\n  cmp eax,9;\r\n  jle _chevron_loop;\r\n\r\n//= Computer text =====================\r\ndrotatescale 0,1; //reset movement and scale\r\ndmove 0;\r\n\r\nin eax,3; //Is inbound?\r\ncmp eax,0;\r\nje _dexit;\r\n\r\n  timer eax; mul eax,2; fint eax; mod eax,2;\r\n  dcolor sgc_text;\r\n  dshade eax;\r\n\r\n  dsetsize 64; //draw message\r\n  dwrite sgc_inboundpos,sgc_inbound;\r\n\r\n_dexit:\r\ndexit;\r\n\r\n//= Helpers ===========================\r\n\r\nchevron_triggers:\r\ndb 9,4,5,6,7,1,2,3,8;\r\n// 1 2 3 4 5 6 7 8 9\r\n// Order in which chevrons light up\r\n// Only 1-7 are used though\r\n\r\n//=====================================\r\n\r\ncolor sgc_text,255,255,255;\r\n\r\nvector2f sgc_inboundpos,120,215;\r\nstring sgc_inbound,'INBOUND';\r\n\r\ncolor stargate_out_ring,    116,105, 76;\r\ncolor stargate_middle_ring, 93 , 85, 60;\r\ncolor stargate_inner_ring,  138,137,108;\r\ncolor stargate_eventhorizon, 93,114,162;\r\ncolor stargate_chevron,     250,162, 54;\r\ncolor iris_color,           192,192,192;\r\n\r\ncolor black,0,0,0;\r\n\r\nvector2f center,256,256;\r\n\r\nvector2f iris1,-44,0;\r\nvector2f iris2,44,175;\r\n\r\nvector2f chevcenter,-16,-256;\r\nvector2f chevsize,32,32;\r\n\r\nalloc eventhorizon_radius;\r\nalloc iris_status;\r\n\r\n//raw chevron poly data\r\n//format: <x> <y>\r\nchevron_polygon: //n=4\r\ndb -16,-251;\r\ndb 16,-251;\r\ndb 10,-230;\r\ndb -10,-230;\r\n"},"gpuchip/lib/":{"gpuchip/lib/drivers/":{"gpuchip/lib/drivers/drv_gl_toolkit.txt":"#ifndef GL\r\n#include <drivers\\drv_gl.txt>\r\n#endif\r\n\r\n#ifndef GLT\r\n\r\n#define GLT\r\n#define GLT_MAX_TRIANGLES 32\r\n\r\nfloat __GLT_VERTBUFF[(GLT_MAX_TRIANGLES * 3) * 3];\r\nfloat __GLT_VERTCNT = 0;\r\n\r\nvoid gltVertex(float x, float y, float z)\r\n{\r\n    if ((__GLT_VERTCNT / 3) >= GLT_MAX_TRIANGLES)\r\n        return;\r\n\r\n    float* ptr = __GLT_VERTBUFF;\r\n    ptr += (__GLT_VERTCNT * 3);\r\n\r\n    *ptr = x;\r\n    *(++ptr) = y;\r\n    *(++ptr) = z;\r\n\r\n    __GLT_VERTCNT++;\r\n}\r\n\r\nvoid gltTriangle(float x1, float y1, float z1,\r\n                 float x2, float y2, float z2,\r\n                 float x3, float y3, float z3)\r\n{\r\n    gltVertex(x1, y1, z1);\r\n    gltVertex(x2, y2, z2);\r\n    gltVertex(x3, y3, z3);\r\n}\r\n\r\nvoid gltQuad(float tlx, float tly, float tlz,\r\n             float trx, float try, float trz,\r\n             float brx, float bry, float brz,\r\n             float blx, float bly, float blz)\r\n{\r\n    gltTriangle(\r\n        trx, try, trz,\r\n        tlx, tly, tlz,\r\n        blx, bly, blz\r\n    );\r\n\r\n    gltTriangle(\r\n        brx, bry, brz,\r\n        trx, try, trz,\r\n        blx, bly, blz\r\n    );\r\n}\r\n\r\nvoid gltCube(float cex, float cey, float cez, float size)\r\n{\r\n    float s2 = size / 2;\r\n\r\n    gltQuad(\r\n        cex - s2, cey + s2, cez - s2,\r\n        cex + s2, cey + s2, cez - s2,\r\n        cex + s2, cey - s2, cez - s2,\r\n        cex - s2, cey - s2, cez - s2\r\n    );\r\n\r\n    gltQuad(\r\n        cex + s2, cey + s2, cez + s2,\r\n        cex - s2, cey + s2, cez + s2,\r\n        cex - s2, cey - s2, cez + s2,\r\n        cex + s2, cey - s2, cez + s2\r\n    );\r\n\r\n    gltQuad(\r\n        cex - s2, cey + s2, cez + s2,\r\n        cex - s2, cey + s2, cez - s2,\r\n        cex - s2, cey - s2, cez - s2,\r\n        cex - s2, cey - s2, cez + s2\r\n    );\r\n\r\n    gltQuad(\r\n        cex + s2, cey + s2, cez - s2,\r\n        cex + s2, cey + s2, cez + s2,\r\n        cex + s2, cey - s2, cez + s2,\r\n        cex + s2, cey - s2, cez - s2\r\n    );\r\n\r\n    gltQuad(\r\n        cex - s2, cey + s2, cez + s2,\r\n        cex + s2, cey + s2, cez + s2,\r\n        cex + s2, cey + s2, cez - s2,\r\n        cex - s2, cey + s2, cez - s2\r\n    );\r\n\r\n    gltQuad(\r\n        cex - s2, cey - s2, cez - s2,\r\n        cex + s2, cey - s2, cez - s2,\r\n        cex + s2, cey - s2, cez + s2,\r\n        cex - s2, cey - s2, cez + s2\r\n    );\r\n}\r\n\r\nvoid gltClearBuffer()\r\n{\r\n    __GLT_VERTCNT = 0;\r\n}\r\n\r\nvoid gltFlushBuffer()\r\n{\r\n    if (__GLT_VERTCNT <= 3)\r\n        return;\r\n\r\n    float vcnt = __GLT_VERTCNT;\r\n    float tcnt = (vcnt / 3) - (vcnt % 3);\r\n\r\n    if (tcnt > GLT_MAX_TRIANGLES)\r\n        tcnt = GLT_MAX_TRIANGLES;\r\n\r\n    glPoly3D(__GLT_VERTBUFF, tcnt);\r\n    glFlush();\r\n}\r\n\r\n#endif\r\n","gpuchip/lib/drivers/drv_gl.txt":"// [Author] - Drunkie\r\n// [Description] - A graphics driver that provides C-style functions for GPU\r\n// [Documentation] - http://goo.gl/DHhYb\r\n\r\n\r\n#define GL\r\n\r\n// Font\r\n#define GL_FONT_LUCIDA_CONSOLE 0\r\n#define GL_FONT_COURIER_NEW 1\r\n#define GL_FONT_TREBUCHET 2\r\n#define GL_FONT_ARIAL 3\r\n#define GL_FONT_TIMES_NEW_ROMAN 4\r\n#define GL_FONT_COOLVETICA 5\r\n#define GL_FONT_AKBAR 6\r\n#define GL_FONT_CSD 7\r\n\r\n// Buffer\r\n#define GL_BUFFER_FRONT 0\r\n#define GL_BUFFER_BACK 1\r\n#define GL_BUFFER_SPRITE 1\r\n#define GL_BUFFER_VERTEX 2\r\n\r\n// Coordinate pipe\r\n#define GL_CPIPE_DIRECT 0\r\n#define GL_CPIPE_RESOLUTION 1\r\n#define GL_CPIPE_0_1 2\r\n#define GL_CPIPE_N1_1 3\r\n#define GL_CPIPE_N256_256 4\r\n\r\n// Vertex pipe\r\n#define GL_VPIPE_XY 0\r\n#define GL_VPIPE_YZ 1\r\n#define GL_VPIPE_XZ 2\r\n#define GL_VPIPE_XYZPROJ 3\r\n#define GL_VPIPE_XYTRANSFORM 4\r\n#define GL_VPIPE_XYZTRANSFORM 5\r\n\r\n// denable / ddisable\r\n#define GL_VERTEX_BUFFER 0\r\n#define GL_VERTEX_ZSORT 1\r\n#define GL_VERTEX_LIGHTING 2\r\n#define GL_VERTEX_CULLING 3\r\n#define GL_VERTEX_DCULLING 4\r\n#define GL_VERTEX_TEXTURING 5\r\n\r\n// Fillmode\r\n#define GL_FILL_SOLID 0\r\n#define GL_FILL_WIREFRAME 1\r\n#define GL_FILL_TEXTURE 2\r\n\r\n// Cullmode\r\n#define GL_CULL_FRONT 0\r\n#define GL_CULL_BACK 1\r\n\r\n// Lightmode\r\n#define GL_LIGHT_FRONT 1\r\n#define GL_LIGHT_BACK -1\r\n\r\n// Horizontal font\r\n#define GL_ALIGN_LEFT 0\r\n#define GL_ALIGN_CENTER 1\r\n#define GL_ALIGN_RIGHT 2\r\n\r\n// Vertical font\r\n#define GL_VALIGN_TOP 0\r\n#define GL_VALIGN_MIDDLE 1\r\n#define GL_VALIGN_BOTTOM 2\r\n\r\n// Compatibility\r\n#define glSetTexture glBindTexture\r\n#define glWriteFmt glWriteFormat\r\n#define glFontHAlign glFontAlign\r\n\r\n\r\n// Clear\r\nvoid glClear( float r, float g, float b ) {\r\n    mov #GL_BG.r,r; mov #GL_BG.g,g; mov #GL_BG.b,b; mov #GL_BG.a,255;\r\n    dclrscr GL_BG;\r\n}\r\nvoid glClear4( float r, float g, float b, float a ) {\r\n    mov #GL_BG.r,r; mov #GL_BG.g,g; mov #GL_BG.b,b; mov #GL_BG.a,a;\r\n    dclrscr GL_BG;\r\n}\r\nvoid glClearTexture() {\r\n    dclrtex;\r\n}\r\nvoid glHWClear( float n ) {\r\n    mov #regHWClear,n;\r\n}\r\n\r\n// Color\r\nvoid glColor( float r, float g, float b ) {\r\n    mov #GL_FG.r,r; mov #GL_FG.g,g; mov #GL_FG.b,b; mov #GL_FG.a,255;\r\n    dcolor GL_FG;\r\n}\r\nvoid glColor4( float r, float g, float b, float a ) {\r\n    mov #GL_FG.r,r; mov #GL_FG.g,g; mov #GL_FG.b,b; mov #GL_FG.a,a;\r\n    dcolor GL_FG;\r\n}\r\nvoid glBrightness( float r, float g, float b, float a ) {\r\n    mov #regBrightnessR,r;\r\n    mov #regBrightnessG,g;\r\n    mov #regBrightnessB,b;\r\n    mov #regBrightnessW,a;\r\n}\r\nvoid glContrast( float r, float g, float b, float a ) {\r\n    mov #regContrastR,r;\r\n    mov #regContrastG,g;\r\n    mov #regContrastB,b;\r\n    mov #regContrastW,a;\r\n}\r\nvoid glShade( float n ) {\r\n    dshade n;\r\n}\r\nvoid glShadeNorm( float n ) {\r\n    dshadenorm n;\r\n}\r\n\r\n// Texture\r\nvoid glBindTexture( char* str ) {\r\n    dxtexture str;\r\n}\r\nvoid glTexture( float id ) {\r\n    dtexture id;\r\n}\r\nvoid glTextureSize( float n ) {\r\n    mov #regTexSize,n;\r\n}\r\nvoid glTextureDataPtr( float n ) {\r\n    mov #regTexDataPtr,n;\r\n}\r\nvoid glTextureDataSize( float n ) {\r\n    mov #regTexDataSz,n;\r\n}\r\nvoid glTextureRotation( float n ) {\r\n    mov #regTexRotation,n;\r\n}\r\nvoid glTextureScale( float n ) {\r\n    mov #regTexScale,n;\r\n}\r\nvoid glTextureCenterUV( float u, float v ) {\r\n    mov #regTexCenterU,u;\r\n    mov #regTexCenterV,v;\r\n}\r\nvoid glTextureOffsetUV( float u, float v ) {\r\n    mov #regTexOffsetU,u;\r\n    mov #regTexOffsetV,v;\r\n}\r\n\r\n// Frame\r\nvoid glSleep( float ms ) {\r\n    div ms,1000;\r\n    timer #GL_CURTIME;\r\n    sub #GL_CURTIME,#GL_TIMESTAMP;\r\n    if (*GL_CURTIME <= ms) {\r\n        mov #regHWClear,0;\r\n        dexit;\r\n    }\r\n    timer #GL_TIMESTAMP;\r\n}\r\nvoid glExit() {\r\n    dexit;\r\n}\r\n\r\n// Pipeline\r\nvoid glCoordPipe( float c ) {\r\n    dcpipe c;\r\n}\r\nvoid glVertexPipe( float v ) {\r\n    dvxpipe v;\r\n}\r\n\r\n// Hardware\r\nvoid glReset( float n ) {\r\n    mov #regReset,n;\r\n}\r\nvoid glHalt( float n ) {\r\n    mov #regHalt,n;\r\n}\r\nvoid glRAMReset( float n ) {\r\n    mov #regRAMReset,n;\r\n}\r\nvoid glHScale( float n ) {\r\n    mov #regHScale,n;\r\n}\r\nvoid glVScale( float n ) {\r\n    mov #regVScale,n;\r\n}\r\nvoid glHWScale( float n ) {\r\n    mov #regHWScale,n;\r\n}\r\nvoid glHWRotate( float n ) {\r\n    mov #regRotation,n;\r\n}\r\n\r\n// Offset\r\nvoid glOffset( float x, float y ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    dmove GL_V1;\r\n}\r\nfloat glOffsetX() {\r\n    preserve eax;\r\n    mov eax,#regOffsetX;\r\n}\r\nfloat glOffsetY() {\r\n    preserve eax;\r\n    mov eax,#regOffsetY;\r\n}\r\nvoid glCenter( float x, float y ) {\r\n    mov #regCenterX,x;\r\n    mov #regCenterY,y;\r\n}\r\n\r\n// Async\r\nvoid glAsyncReset( float n ) {\r\n    mov #regAsyncReset,n;\r\n}\r\nvoid glAsyncClk( float n ) {\r\n    mov #regAsyncClk,n;\r\n}\r\nvoid glAsyncFreq( float n ) {\r\n    mov #regAsyncFreq,n;\r\n}\r\nvoid glEntryPoint( float idx, float ptr ) {\r\n    dentrypoint idx,ptr;\r\n}\r\nvoid glBegin() {\r\n    dbegin;\r\n}\r\nvoid glEnd() {\r\n    dend;\r\n}\r\nvoid glSwap() {\r\n    dswap;\r\n}\r\nvoid glSync() {\r\n    dvsync;\r\n}\r\n\r\n// Cursor\r\nvoid glCursor( float n ) {\r\n    mov #regCursor,n;\r\n}\r\nfloat glCursorX() {\r\n    preserve eax;\r\n    mov eax,#regCursorX;\r\n}\r\nfloat glCursorY() {\r\n    preserve eax;\r\n    mov eax,#regCursorY;\r\n}\r\n\r\n// Circle\r\nvoid glCircleQuality( float n ) {\r\n    mov #regCircleQuality,n;\r\n}\r\nvoid glCircleStart( float n ) {\r\n    mov #regCircleStart,n;\r\n}\r\nvoid glCircleEnd( float n ) {\r\n    mov #regCircleEnd,n;\r\n}\r\n\r\n// Screen scaling\r\nvoid glScreenScale( float n ) {\r\n    mov #regScale,n;\r\n}\r\nvoid glScreenScaleX( float x ) {\r\n    mov #regScaleX,x;\r\n}\r\nvoid glScreenScaleY( float y ) {\r\n    mov #regScaleY,y;\r\n}\r\n\r\n// 2D graphics\r\nvoid glCircle( float x, float y, float radius ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    dcircle GL_V1,radius;\r\n}\r\nvoid glRect( float x, float y, float dx, float dy ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    mov #GL_V2.x,dx; mov #GL_V2.y,dy;\r\n    drect GL_V1,GL_V2;\r\n}\r\nvoid glRectWH( float x, float y, float w, float h ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    mov #GL_V2.x,w; mov #GL_V2.y,h;\r\n    drectwh GL_V1,GL_V2;\r\n}\r\nvoid glORect( float x, float y, float dx, float dy ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    mov #GL_V2.x,dx; mov #GL_V2.y,dy;\r\n    dorect GL_V1,GL_V2;\r\n}\r\nvoid glORectWH( float x, float y, float w, float h ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    mov #GL_V2.x,w; mov #GL_V2.y,h;\r\n    dorectwh GL_V1,GL_V2;\r\n}\r\nvoid glPixel( float x, float y ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    dpixel GL_V1,GL_FG;\r\n}\r\nvoid glLine( float x, float y, float dx, float dy ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    mov #GL_V2.x,dx; mov #GL_V2.y,dy;\r\n    dline GL_V1,GL_V2;\r\n}\r\nvoid glLineWidth( float w ) {\r\n    dsetwidth w;\r\n}\r\nvoid glPoly2D( float* buffer, float count ) {\r\n    dvxdata_2f buffer,count;\r\n}\r\n\r\n\r\n// Text\r\nvoid glFont( float id ) {\r\n    dsetfont id;\r\n}\r\nvoid glFontAlign( float n ) {\r\n    mov #regFontHalign,n;\r\n}\r\nvoid glFontVAlign( float n ) {\r\n    mov #regFontValign,n;\r\n}\r\nvoid glFontSize( float n ) {\r\n    dsetsize n;\r\n}\r\nfloat glTextWidth( char* str ) {\r\n    preserve eax;\r\n    dtextwidth eax,str;\r\n}\r\nfloat glTextHeight( char* str ) {\r\n    preserve eax;\r\n    dtextheight eax,str;\r\n}\r\nvoid glWriteString( float x, float y, char* str ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    dwrite GL_V1,str;\r\n}\r\nvoid glWriteFloat( float x, float y, float n ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    dwritef GL_V1,n;\r\n}\r\nvoid glWriteInt( float x, float y, float n ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    dwritei GL_V1,n;\r\n}\r\nvoid glWriteFormat( float x, float y, char* str ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    dwritefmt GL_V1,str;\r\n}\r\nfloat glParamList() {\r\n    preserve eax;\r\n    mov eax,#regParamList;\r\n}\r\n\r\n\r\n// 3D graphics\r\nvoid glPoly3D( float* buffer, float count ) {\r\n\r\n    if (*GL_MUPDATE == 1) {\r\n        mov #GL_MUPDATE,0;\r\n        mrotate GL_MROTATEMATRIX,GL_VROTATE;\r\n        mtranslate GL_MTRANSLATEMATRIX,GL_VTRANSLATE;\r\n        mscale GL_MSCALEMATRIX,GL_VSCALE;\r\n        mmov GL_MMODELMATRIX,GL_MTRANSLATEMATRIX;\r\n        mmul GL_MMODELMATRIX,GL_MROTATEMATRIX;\r\n        mmul GL_MMODELMATRIX,GL_MSCALEMATRIX;\r\n        mmov GL_MMODELVIEWMATRIX,GL_MVIEWMATRIX;\r\n        mmul GL_MMODELVIEWMATRIX,GL_MMODELMATRIX;\r\n        mload GL_MMODELVIEWMATRIX;\r\n        mloadproj GL_MPROJECTIONMATRIX;\r\n    }\r\n\r\n    if (*GL_FILLMODE == GL_FILL_SOLID) {\r\n        dvxdata_3f buffer,count;\r\n    }\r\n    else if (*GL_FILLMODE == GL_FILL_WIREFRAME) {\r\n        dvxdata_3f_wf buffer,count;\r\n    }\r\n    else if (*GL_FILLMODE == GL_FILL_TEXTURE) {\r\n        dvxdata_3f_tex buffer,count\r\n    }\r\n}\r\nvoid glFlush() {\r\n    dvxflush;\r\n}\r\nvoid glEnable( float n ) {\r\n    denable n;\r\n}\r\nvoid glDisable( float n ) {\r\n    ddisable n;\r\n}\r\nvoid glLightPos( float x, float y, float z ) {\r\n    mov #GL_LIGHTPOS.x,x; mov #GL_LIGHTPOS.y,y; mov #GL_LIGHTPOS.z,z;\r\n    dsetlight 0,GL_LIGHTDATA;\r\n}\r\nvoid glLightColor( float r, float g, float b, float a ) {\r\n    mov #GL_LIGHTCOL.r,r; mov #GL_LIGHTCOL.g,g;\r\n    mov #GL_LIGHTCOL.b,b; mov #GL_LIGHTCOL.a,a;\r\n    dsetlight 0,GL_LIGHTDATA;\r\n}\r\nvoid glFillMode( float n ) {\r\n    mov #GL_FILLMODE,n;\r\n}\r\nvoid glLookAt( float x, float y, float z, float tx, float ty, float tz, float ux, float uy, float uz ) {\r\n    mov #GL_VLOOKAT_POS.x,x; mov #GL_VLOOKAT_POS.y,y; mov #GL_VLOOKAT_POS.z,z;\r\n    mov #GL_VLOOKAT_TARG.x,tx; mov #GL_VLOOKAT_TARG.y,ty; mov #GL_VLOOKAT_TARG.z,tz;\r\n    mov #GL_VLOOKAT_UP.x,ux; mov #GL_VLOOKAT_UP.y,uy; mov #GL_VLOOKAT_UP.z,uz;\r\n    mlookat GL_MVIEWMATRIX,GL_VLOOKAT;\r\n    mov #GL_MUPDATE,1;\r\n}\r\nvoid glPerspective( float fov, float asp, float znear, float zfar ) {\r\n    mov #GL_VPERSPECTIVE.x,fov; mov #GL_VPERSPECTIVE.y,asp;\r\n    mov #GL_VPERSPECTIVE.z,znear; mov #GL_VPERSPECTIVE.w,zfar;\r\n    mperspective GL_MPROJECTIONMATRIX,GL_VPERSPECTIVE;\r\n    mov #GL_MUPDATE,1;\r\n}\r\nvoid glRotate( float x, float y, float z, float w ) {\r\n    mov #GL_VROTATE.x,x; mov #GL_VROTATE.y,y; mov #GL_VROTATE.z,z; mov #GL_VROTATE.w,w;\r\n    mov #GL_MUPDATE,1;\r\n}\r\nvoid glTranslate( float x, float y, float z ) {\r\n    mov #GL_VTRANSLATE.x,x; mov #GL_VTRANSLATE.y,y; mov #GL_VTRANSLATE.z,z;\r\n    mov #GL_MUPDATE,1;\r\n}\r\nvoid glScale( float x, float y, float z ) {\r\n    mov #GL_VSCALE.x,x; mov #GL_VSCALE.y,y; mov #GL_VSCALE.z,z;\r\n    mov #GL_MUPDATE,1;\r\n}\r\nvoid glZOffset( float n ) {\r\n    mov #regZOffset,n;\r\n}\r\nvoid glCullDistance( float n ) {\r\n    mov #regCullDistance,n;\r\n}\r\nvoid glCullMode( float n ) {\r\n    mov #regCullMode,n;\r\n}\r\nvoid glLightMode( float n ) {\r\n    mov #regLightMode,n;\r\n}\r\nvoid glVertexArray( float n ) {\r\n    mov #regVertexArray,n;\r\n}\r\n\r\n// Other\r\nvoid glVertexMode( float n ) {\r\n    mov #regVertexMode,n;\r\n}\r\nvoid glSetRenderTarget( float n ) {\r\n    if (n == GL_BUFFER_FRONT) {\r\n        dsetbuf_fbo;\r\n    }\r\n    else if (n == GL_BUFFER_BACK) {\r\n        dsetbuf_spr;\r\n    }\r\n    else if (n == GL_BUFFER_VERTEX) {\r\n        dsetbuf_vx;\r\n    }\r\n}\r\nfloat glIndex() {\r\n    preserve eax;\r\n    mov eax,#regIndex;\r\n}\r\n\r\n\r\n// Allocated variables for GL\r\ncolor GL_FG,255,255,255;\r\ncolor GL_BG;\r\nvec4f GL_V1;\r\nvec4f GL_V2;\r\n\r\nalloc GL_TIMESTAMP;\r\nalloc GL_CURTIME;\r\nalloc GL_FILLMODE;\r\n\r\nGL_LIGHTDATA:\r\nvec4f GL_LIGHTPOS,0,0,-10;\r\ncolor GL_LIGHTCOL,255,255,255,1;\r\n\r\nGL_VLOOKAT:\r\nvec3f GL_VLOOKAT_POS,0,0,-10;\r\nvec3f GL_VLOOKAT_TARG,0,0,0;\r\nvec3f GL_VLOOKAT_UP,0,1,0;\r\n\r\nmatrix GL_MROTATEMATRIX;\r\nmatrix GL_MTRANSLATEMATRIX;\r\nmatrix GL_MSCALEMATRIX;\r\nmatrix GL_MPROJECTIONMATRIX;\r\nmatrix GL_MVIEWMATRIX;\r\nmatrix GL_MMODELMATRIX;\r\nmatrix GL_MMODELVIEWMATRIX;\r\nalloc GL_MUPDATE,1;\r\n\r\nvec4f GL_VROTATE;\r\nvec4f GL_VTRANSLATE;\r\nvec4f GL_VPERSPECTIVE;\r\nvec4f GL_VSCALE,1,1,1,0;\r\n"}}},"spuchip/":{"spuchip/examples/":{"spuchip/examples/mario_theme.txt":"// Author: Jasongamer\r\n// Song: Mario Underwater Theme\r\n\r\n// Set track wave to channel 0 and start\r\nwset 0,trackwave;\r\nchwave 0,0;\r\nchvolume 0,0.2;\r\nchstart 0;\r\n\r\n// Set track wave to channel 1 and start\r\nwset 1,trackwave;\r\nchwave 1,1;\r\nchvolume 1,0.2;\r\nchstart 1;\r\n\r\n// Set bass wave to channel 2 and start\r\nwset 2,basswave;\r\nchwave 2,1;\r\nchvolume 2,0.3;\r\nchstart 2;\r\n\r\n// Get track length\r\ntracklen = strlen(trackA);\r\n\r\nvoid main()\r\n{\r\n    // Tempo\r\n    if ((i > 120) && (i <= 230))\r\n        tempo( 1000 );\r\n    else\r\n        tempo( 864 );\r\n\r\n    // Track A\r\n    note = 2;\r\n    fpwr note,(trackA[i]/12);\r\n    note /= 100;\r\n    chpitch 0,note;\r\n\r\n    // Track B\r\n    note = 2;\r\n    fpwr note,(trackB[i]/12);\r\n    note /= 100;\r\n    chpitch 1,note;\r\n\r\n    // Bass\r\n    note = 2;\r\n    fpwr note,(bass[i]/12);\r\n    note /= 100;\r\n    chpitch 2,note;\r\n\r\n    // Index\r\n    i++; mod i,tracklen;\r\n\r\n    // Repeat\r\n    jmp main;\r\n}\r\n\r\n// Accurate tempo function for beats-per-minute\r\nvoid tempo( float bpm )\r\n{\r\n    timer timestamp;\r\n    while ((time - timestamp) < (60 / bpm)) { timer time; }\r\n}\r\n\r\n// Returns the length of a string\r\nfloat strlen(char* str)\r\n{\r\n  char* strptr = str;\r\n  while (*strptr++);\r\n  return (strptr - str);\r\n}\r\n\r\nfloat note, i;\r\nfloat tracklen;\r\nfloat time, timestamp;\r\n\r\nstring trackwave,\"synth/square.wav\";\r\nstring basswave,\"synth/tri.wav\";\r\n\r\ntrackA:\r\n\r\n// Intro\r\ndb 73,73,73,73, 75,75,75,75, 77,77,77,77,   78,78,78,78, 80,80,80,80, 81,81,81,81;\r\ndb 82,-1,82,-1, 82,82,82,-1, 82,82,82,-1,   82,82,82,82, 82,82,82,-1, -1,-1,78,78;\r\n\r\n// Part 1\r\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   86,86,86,86, 86,86,86,86, 86,86,86,-1;\r\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   -1,-1,78,78, 80,80,82,82, 83,83,85,85;\r\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   86,86,86,86, 86,86,86,-1, 88,88,88,-1;\r\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,78,78;\r\ndb 85,85,85,85, 85,85,85,85, 85,85,85,-1,   84,84,84,84, 84,84,84,84, 84,84,84,-1;\r\ndb 85,85,85,85, 85,85,85,85, 85,85,85,-1,   -1,-1,78,78, 80,80,82,82, 83,83,84,84;\r\ndb 85,85,85,85, 85,85,85,85, 85,85,85,-1,   78,78,78,78, 78,78,78,-1, 88,88,88,-1;\r\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,78,78;\r\n\r\n// Part 2\r\ndb 90,90,90,90, 90,90,90,90, 90,90,90,-1,   90,90,90,90, 90,90,90,90, 90,90,90,-1;\r\ndb 90,90,90,90, 90,90,90,90, 90,90,90,-1,   90,90,90,-1, 92,92,-1,-1, -1,-1,90,90;\r\ndb 88,88,88,88, 88,88,88,88, 88,88,88,-1,   88,88,88,88, 88,88,88,88, 88,88,88,-1;\r\ndb 88,88,88,88, 88,88,88,88, 88,88,88,-1,   88,88,88,-1, 90,90,-1,-1, -1,-1,88,88;\r\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   80,80,80,-1, 82,82,82,-1, 88,88,88,-1;\r\ndb 87,-1,87,-1, 87,87,87,87, 87,-1,82,82,   83,83,83,83, 83,83,83,83, 83,83,83,-1;\r\n\r\ndb 0; // End string\r\n\r\ntrackB:\r\n\r\n// Intro\r\ndb 73,73,73,73, 72,72,72,72, 71,71,71,71,   70,70,70,70, 71,71,71,71, 72,72,72,72;\r\ndb 73,-1,73,-1, 73,73,73,-1, 75,75,75,-1,   76,76,76,76, 76,76,76,-1, -1,-1,-1,-1;\r\n\r\n// Part 1\r\ndb 78,78,78,78, 78,78,78,78, 78,78,78,-1,   77,77,77,77, 77,77,77,77, 77,77,77,-1;\r\ndb 78,78,78,78, 78,78,78,78, 78,78,78,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\r\ndb 78,78,78,78, 78,78,78,78, 78,78,78,-1,   77,77,77,77, 77,77,77,-1, 80,80,80,-1;\r\ndb 78,78,78,78, 78,78,78,78, 78,78,78,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\r\ndb 76,76,76,76, 76,76,76,76, 76,76,76,-1,   75,75,75,75, 75,75,75,75, 75,75,75,-1;\r\ndb 76,76,76,76, 76,76,76,76, 76,76,76,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\r\ndb 76,76,76,76, 76,76,76,76, 76,76,76,-1,   70,70,70,70, 70,70,70,-1, 80,80,80,-1;\r\ndb 78,78,78,78, 78,78,78,78, 78,78,78,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\r\n\r\n// Part 2\r\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   85,85,85,85, 85,85,85,85, 85,85,85,-1;\r\ndb 84,84,84,84, 84,84,84,84, 84,84,84,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\r\ndb 85,85,85,85, 85,85,85,85, 85,85,85,-1,   84,84,84,84, 84,84,84,84, 84,84,84,-1;\r\ndb 83,83,83,83, 83,83,83,83, 83,83,83,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\r\ndb 71,71,71,71, 71,71,71,71, 71,71,71,-1,   76,76,76,-1, 78,78,78,-1, 82,82,82,-1;\r\ndb 82,-1,82,-1, 82,82,82,-1, -1,-1,76,76,   75,75,75,75, 75,75,75,75, 75,75,75,-1;\r\n\r\ndb 0; // End string\r\n\r\nbass:\r\n\r\n// Intro\r\ndb -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\r\ndb -1,-1,-1,-1, -1,-1,-1,-1, 66,66,66,-1, 66,66,66,66, 66,66,66,66, 66,66,66,-1;\r\n\r\n// Part 1\r\ndb 59,59,59,-1, 66,66,66,-1, 71,71,71,-1, 58,58,58,-1, 66,66,66,-1, 70,70,70,-1;\r\ndb 59,59,59,-1, 66,66,66,-1, 71,71,71,-1, 63,63,63,-1, 66,66,66,-1, 71,71,71,-1;\r\ndb 59,59,59,-1, 66,66,66,-1, 71,71,71,-1, 58,58,58,-1, 66,66,66,-1, 70,70,70,-1;\r\ndb 59,59,59,-1, 66,66,66,-1, 71,71,71,-1, 63,63,63,-1, 66,66,66,-1, 71,71,71,-1;\r\ndb 61,61,61,-1, 66,66,66,-1, 70,70,70,-1, 60,60,60,-1, 65,65,65,-1, 69,69,69,-1;\r\ndb 61,61,61,-1, 66,66,66,-1, 70,70,70,-1, 58,58,58,-1, 66,66,66,-1, 70,70,70,-1;\r\ndb 61,61,61,-1, 66,66,66,-1, 70,70,70,-1, 58,58,58,-1, 66,66,66,-1, 70,70,70,-1;\r\ndb 59,59,59,-1, 66,66,66,-1, 71,71,71,-1, 54,54,54,-1, 66,66,66,-1, 71,71,71,-1;\r\n\r\n// Part 2\r\ndb 59,59,59,-1, 66,66,66,-1, 75,75,75,-1, 58,58,58,-1, 66,66,66,-1, 73,73,73,-1;\r\ndb 57,57,57,-1, 66,66,66,-1, 72,72,72,-1, 60,60,60,-1, 66,66,66,-1, 75,75,75,-1;\r\ndb 61,61,61,-1, 68,68,68,-1, 76,76,76,-1, 60,60,60,-1, 68,68,68,-1, 76,76,76,-1;\r\ndb 59,59,59,-1, 68,68,68,-1, 76,76,76,-1, 58,58,58,-1, 66,66,66,-1, 76,76,76,-1;\r\ndb 47,47,47,-1, 66,66,66,-1, 75,75,75,-1, 54,54,54,-1, 66,66,66,-1, 66,66,66,-1;\r\ndb 64,-1,64,-1, 64,64,64,-1, -1,-1,58,58, 59,59,59,59, 59,59,59,59, 59,59,59,-1;\r\n\r\ndb 0; // End string\r\n","spuchip/examples/beatbox.txt":"wset 4,inst1;\r\nchwave 1,4;\r\nchpitch 1,2.55;\r\n\r\nchwave 2,0;\r\nchvolume 2,0.5;\r\nchstart 2;\r\nchpitch 2,0;\r\n\r\nmainloop:\r\n  timer r0;\r\n  mul r0,6;\r\n  mov r1,r0;\r\n\r\n  fint r0;\r\n  mod r0,16;\r\n  add r0,0;\r\n  mod r1,1;\r\n  currentTick = r0;\r\n  currentTickTime = r1;\r\n\r\n  instr1 = patternData1[currentTick];\r\n  instr2 = patternData2[currentTick];\r\n  instr3 = patternData3[currentTick];\r\n\r\n  if ((pinstr1 == 0) && (instr1 == 1)) {\r\n    chstart 0;\r\n  } else {\r\n    chstop 0;\r\n  }\r\n\r\n  if ((pinstr2 == 0) && (instr2 == 1)) {\r\n    chstart 1;\r\n  } else {\r\n    chstop 1;\r\n  }\r\n\r\n  mov r0,currentTickTime; neg r0; add r0,1; fpwr r0,4;\r\n  mul r0,0.6; // add r0,0.64;\r\n  chpitch 0,r0;\r\n\r\n  mov r0,instr3;\r\n  mul r0,0.1;\r\n  add r0,0.2;\r\n  chpitch 2,r0;\r\njmp mainloop;\r\n\r\nfloat currentTick,currentTickTime;\r\nfloat instr1,instr2,instr3;\r\nfloat pinstr1,pinstr2;\r\n\r\npatternData1: db 1,1,0,0, 1,0,0,0, 1,0,0,1, 0,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,1, 1,0,1,0;\r\npatternData2: db 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0;\r\npatternData3: db 0,1,0,2, 0,1,2,2, 0,0,1,1, 1,2,1,2, 2,2,1,2, 2,2,1,1, 1,1,0,0, 0,0,1,2;\r\n\r\nstring inst1,\"synth/pink_noise.wav\";\r\n"}},"cpuchip/":{"cpuchip/examples/":{"cpuchip/examples/udh_test.txt":"//------------------------------------------------------------------------------\r\n// Universal Device Host driver test application\r\n//------------------------------------------------------------------------------\r\n#pragma CRT ZCRT\r\n\r\n//Include drivers for console screen and device host\r\n#include <drivers\\drv_udh.txt>\r\n#include <drivers\\drv_cscr.txt>\r\n\r\nvoid main() {\r\n  float i;\r\n  udhSetBusAddress(65536);\r\n\r\n  cscrInitialize(0);\r\n\r\n  udhQueryDevices();\r\n\r\n  for (i = 0; i < MAX_CONSOLE_SCREENS; i++) {\r\n    cscrSelect(i);\r\n    cscrSetActive(1);\r\n    cscrClear();\r\n\r\n    cscrSetCursor(0,0);\r\n    cscrPrintLine(\"Screen \",930);\r\n    cscrPrintNumber(i,930);\r\n  }\r\n\r\n  cscrSelect(0);\r\n  cscrSetCursor(0,2);\r\n  cscrPrintLine(\"UDH driver test\\n\",039);\r\n  for (i = 0; i < 8; i++) {\r\n    cscrPrintLine(\"DEVICE \",999);\r\n    cscrPrintNumber(i,999);\r\n    cscrPrintLine(\": \",999);\r\n    cscrPrintLine(udhGetDeviceName(i),666);\r\n    cscrPrintLine(\"\\n\",999);\r\n  }\r\n}\r\n","cpuchip/examples/segments.txt":"/*\r\nThis example assumes you are already familiar with ZASM\r\nas this will be going over semi-advanced features.\r\n\r\nSegment registers allow you to add an offset to memory access\r\nBy default, they are all set to 0 on first startup of CPU\r\nand reset to 0 when the CPU is reset.\r\n\r\nThe available segment registers are\r\nCS - Code Segment, used to read instructions from RAM.\r\n     It can only be changed with far jump instructions, trying to\r\n     set it using other instructions results in an error of #13[1]\r\n\r\n     Setting this allows compiled programs using branches to run\r\n     without having to be compiled knowing where they will sit in\r\n     memory\r\n\r\nSS - Stack Segment, this is where the stack starts from, stack access\r\n     via PUSH, POP, RSTACK, SSTACK is relative to this segment\r\n\r\nDS - Data Segment, default for all memory access instructions\r\n     unless another segment is specified.\r\n\r\nUser Segments, none of these are used internally, so they can be used\r\nwithout fear of altering behavior outside of user programs which use\r\nthese segments\r\nES - Extra Segment\r\nGS - \"G Segment\"\r\nFS - \"F Segment\"\r\nKS - Key Segment\r\nLS - Library Segment\r\n*/\r\n\r\n// Segment registers can be read and written to like any other register\r\nstart:\r\nMOV DS,data_pos\r\nMOV R0,3\r\nMOV R1,[R0] // 3+data_pos, aka the fourth value, 720. Doesn't change R0\r\n            // or DS in order to access and store the value in R1\r\nMOV R2,[0]  // 0+data_pos, aka the first value, 640.\r\nJMP end_data_pos\r\ndata_pos:\r\nDB 640,480\r\nDB 1280,720\r\nDB 0\r\nend_data_pos:\r\n\r\nMOV R3,[CS:0]  // Segment for access can be specified with SEG:Value\r\nMOV R4,[EAX:0] // and any register can be used as a segment\r\nMOV R5,R0:0    // This does nothing\r\n\r\n/*\r\nLEA is one of the few instructions that use a user defined segment\r\noutside of memory access, and it writes the value of the address used\r\nby a memory access to the left hand side, it is effectively the same as\r\n\r\nMOV EAX,R0 //(EAX is just a standin for an unused register)\r\nADD EAX,DS //(or the segment explicitly defined instead of DS)\r\nMOV R7,EAX\r\n\r\n^\r\nthis code uses 6 bytes, where LEA uses:\r\n2 bytes(no segment supplied, register to register transfer I.E LEA R7,R0)\r\n3 bytes(segment supplied by user, register to register transfer I.E LEA R7,SS:R0)\r\n\r\n*/ \r\n\r\nLEA R6,[R0]    // This will put DS+R0 into R6 (data_pos+3)\r\nLEA R7,[SS:R0] // This will put SS+R0 into R7(SS+3)\r\n\r\n/*\r\nWire your CPU to a memory device\r\nand upload your own program to the device\r\nby clicking on it as if it were a CPU\r\n \r\nIf this example is uploaded to your CPU\r\nit will begin running the code on the\r\nmemory device as if it were running on\r\nthe original CPU, to debug the program\r\npress compile with your code open in the\r\neditor, afterward \"Step Forward\" will begin\r\nshowing the proper lines.\r\n*/\r\n\r\nCPUGET DS,43 // Get RAM size of CPU, aka the first byte of external memory.\r\nJMPF 0,DS   // JMP to 0 + DS, setting CS to DS\r\n\r\n/*\r\nYour program will now run from here until\r\nit errors or you reset it.\r\n*/\r\n","cpuchip/examples/helloworld.txt":"//Wired Hello World!\r\n//Connect CPU membus input to console screen\r\n//Connect CPUs CLK input to button (toggle)\r\n//Notice how you can store your\r\n//subroutines/calls in DATA area\r\njmp _code;\r\nmessage:\r\n  db 'Hello World!',0;\r\nWriteString: //ESI - String pointer, EDX - Param\r\n  mov eax,65536;\r\n  AWriteLoop:\r\n    cmp #esi,0; //Terminate on char 0\r\n    je AEnd;\r\n    mov #eax,#esi; //Output char\r\n    inc eax;\r\n    mov #eax,edx; //Output char param\r\n    inc eax;\r\n    inc esi;\r\n  jmp AWriteLoop;\r\n  AEnd:\r\nret //Return from call\r\n\r\n_code:\r\n  mov esi,message;\r\n  mov edx,000999; //White foreground on black background\r\n  call WriteString;\r\n\r\n//More about colors:\r\n//Lower 3 digits are foreground,\r\n//and higher 3 digits are background\r\n//Each of 3 digits shows amount of\r\n//RED, GREEN, and BLUE (in order)\r\n//Each color has 10 shades - from 0 to 9\r\n//\r\n//For example, 999044 will be dark yellow (044) on\r\n//a white background (999)\r\n//\r\n//Experiment with colors!\r\n//\r\n//Also, the 7th digit (if its not equal to 0) will\r\n//cause the character to blink by changing foreground and\r\n//background places (actual data in memory wont change)\r\n","cpuchip/examples/interrupts.txt":"/*\r\nThis example assumes you are already familiar with ZASM\r\nas this will be going over advanced features.\r\n\r\nFor setup of this example:\r\n\r\n1. Wire a button outputting value 32 to the Interrupt input on the CPU\r\n2. Connect CPU membus input to a console screen\r\n*/\r\n\r\nDATA\r\n\r\n/*\r\nEach external interrupt is 4 bytes\r\nformatted like so:\r\nInstruction Pointer, Code Segment, PTB, Flags\r\nAvailable flags are\r\nBit 3(8)  : Interrupt will set CMPR to 1, unavailable for external interrupts(they restore CMPR on EXTRET)\r\nBit 4(16) : Interrupt will not set CS\r\nBit 5(32) : Interrupt is enabled\r\nBit 6(64) : Interrupt is external\r\nBit 7(128): Interrupt will replace page table with PTB, which isn't restored on IRET/EXTRET\r\nBit 8(256): Interrupt will replace number of page table entries with PTB, which isn't restored on IRET/EXTRET\r\nBit 9(512): Interrupt will also push R0-R31 to stack, use EXTRETA instead of EXTRET to pop them\r\n\r\nFlags can be combined, do this by adding the numbers together\r\nFor example:\r\n8+32 = Interrupt is active, and on interrupt it will set CMPR to 1\r\n*/\r\nmy_interrupt_table:\r\nALLOC 32*4 // The interrupt table is 0 indexed\r\nDB my_external_interrupt,0,0,96 // so this is index 32\r\nDB my_internal_interrupt,0,0,32 // and this is index 33\r\nDB my_timer_interrupt,0,0,96 // Timer interrupts need to be external\r\nALLOC 24*4 // Fill rest of space to 58 usable interrupts\r\n\r\nexternal_int_str:\r\nDB \"Hello from External Interrupt!\",0\r\n\r\ninternal_int_str:\r\nDB \"Hello from Internal Interrupt!\",0\r\n\r\ntimer_int_str:\r\nDB \"Hello from the Timer Interrupt\",0\r\n\r\nmy_external_interrupt:\r\n    CLI // Turn off the ability for another interrupt to happen\r\n    CPUGET EDI,43 // get external memory and put it in EDI\r\n    ADD EDI,60    // shift mem offset to start on line 2 of console screen\r\n    MOV ESI,external_int_str\r\n    external_int_strcpy: // Copy null terminated string\r\n        MOV [EDI],[ESI]\r\n        MCOPY 1\r\n        MOV [EDI],999 // See helloworld.txt for more information about console colors\r\n        INC EDI\r\n        CMP [ESI],0\r\n    JNE external_int_strcpy\r\n    CLERR // Clear error code on CPU\r\n    STI // Re-enable interrupts before returning from interrupt\r\nEXTRET // You need to use the EXTRET instruction for external interrupts, since IRET only pops IP and CS\r\n// EXTRET pops all 20 bytes from stack that are generated upon an external interrupt\r\n\r\nmy_internal_interrupt:\r\n    // If CLI at start is not present, this interrupt can be interrupted\r\n    // by another interrupt happening during execution.\r\n    CPUGET EDI,43 // get external memory and put it in EDI\r\n    MOV ESI,internal_int_str\r\n    internal_int_strcpy: // Copy null terminated string\r\n        MOV [EDI],[ESI]\r\n        MCOPY 1\r\n        MOV [EDI],999 // See helloworld.txt for more information about console colors\r\n        INC EDI\r\n        CMP [ESI],0\r\n    JNE internal_int_strcpy\r\n    CLERR // Clear error code on CPU\r\nIRET // Registers are not preserved in an internal interrupt, IRET only pops CS and IP to return to\r\n\r\nmy_timer_interrupt:\r\n    CLI\r\n    CPUGET EDI,43 // get external memory and put it in EDI\r\n    ADD EDI,120   // shift mem offset to start on line 3 of console screen\r\n    MOV ESI,timer_int_str\r\n    timer_int_strcpy: // Copy null terminated string\r\n        MOV [EDI],[ESI]\r\n        MCOPY 1\r\n        MOV [EDI],999 // See helloworld.txt for more information about console colors\r\n        INC EDI\r\n        CMP [ESI],0\r\n    JNE timer_int_strcpy\r\n    CLERR // Clear error code on CPU\r\n    STI // re-enable interrupts\r\nEXTRET // Registers are not preserved in an internal interrupt, IRET only pops CS and IP to return to\r\n\r\n\r\nCODE\r\nSTEF // Set the EXTENDED FLAG on, this allows you to call interrupts without halting CPU\r\nLIDTR my_interrupt_table // Load the interrupt table we have in memory\r\nCPUSET 52,59 // Set number of interrupts in table (defaults to 256)\r\nINT 33 // Call interrupt 33 to print to console screen.\r\n// Note that you can also call external interrupts internally using EXTINT (number)\r\nCPUSET 67,34 // Set timer interrupt(external interrupt #) to our timer interrupt\r\nCPUSET 65,4  // Set delay on timer to 4 seconds.\r\nCPUSET 64,1  // Set timer mode to seconds (it will read the 4 as 4 seconds, set to 2 to read as every 4 instructions)\r\n// Timer will now be running from here on.\r\n\r\nwait_forever:\r\nINC R0\r\nJMP wait_forever\r\n// Use CLEF to disable the extended flag if you want to halt on error instead of handle\r\n","cpuchip/examples/stack_setup.txt":"/*\r\nThis example assumes you are already familiar with ZASM\r\nas this will be going over semi-advanced features.\r\n\r\nContains example code for how to change your CPU's stack\r\nsegment and size, and print a string to a console screen\r\nusing only stack instructions\r\n\r\nBy default, on a CPU the stack segment starts at 0, and\r\nthe stack size is set to the RAM size, so if you push to\r\nit too many times, you might start overwriting your own\r\ncode on the CPU, setting up a dedicated stack segment and\r\nstack area is a good idea if you don't know how much stack\r\nyour program could possibly consume.\r\n*/\r\n\r\nCPUGET SS,43 // Set stack segment register to the CPU's internal ram size\r\n             // This will make stack operations access external memory\r\nSUB SS,4     // Move SS back by 2 console screen characters(2 bytes each)\r\nCPUSET 9,32  // Set internal register 9(ESZ, aka stack size) + 2 console chars\r\nMOV ESP,32   // Set stack pointer to stack size\r\n             // You can also use CPUGET ESP,9 to set ESP to current stack size\r\n\r\nMOV ESI,str-1 // Loops end at 0, so we need to start at -1 if we want\r\n              // to read from something with 0 indexing\r\n\r\nMOV ECX,15 // String length + 1\r\n// Remember that stack access is done top(SS+ESP) to bottom\r\n// This reads the string in reverse to push it to stack\r\nprint_loop:\r\nPUSH [ESI:ECX] // Using ESI(containing ptr to str) as a segment to access ECX\r\nPUSH 999       // See helloworld.txt for more information about console colors\r\nLOOP print_loop\r\n\r\nstr:\r\nDB \"Hi from Stack!\" // 14 characters\r\n\r\n","cpuchip/examples/page_rw_override.txt":"/*\r\nThis example assumes you are already familiar with ZASM\r\nas this will be going over advanced features.\r\n\r\nThis will not go too indepth into how the paging\r\nsystem works, but instead focus primarily on the feature\r\nto call an interrupt on read or write of a specific page,\r\nto intercept memory requests and handle them internally.\r\n\r\nRequires CPU memory model to be 8kb ram/rom or above.\r\n\r\nFor setup of this example:\r\n\r\n1. Connect CPU membus input to a console screen\r\n*/\r\n\r\nDATA\r\ninterrupt_table:\r\nALLOC 28*4 // fill interrupt space for 0-27\r\nDB read_mem,0,0,32 // Interrupt 28, called on a delayed memory read\r\nDB write_mem,0,0,32 // Interrupt 29, called on a delayed memory write\r\nALLOC 1*4\r\n\r\npage_table:\r\nALLOC 16*2 // Entries for the paging table are 2 bytes each.\r\n\r\n\r\n// For more information on interrupts, read the interrupts example\r\nread_mem:\r\nCLI\r\nCLM // Disable paging features temporarily\r\n    CPUGET ESI,63   // The requested address for the request\r\n    CPUSET 27,[ESI] // Return the value in LADD\r\n    CPUSET 42,4     // Set MEMRQ to 4 to signify read was handled\r\nSTM // Reenable paging features after read is performed\r\nCLERR\r\nSTI\r\nIRET\r\n\r\nwrite_mem:\r\nCLI\r\n    CPUGET EAX,27 // Get value requested for write\r\n    CPUGET EDI,63 // Requested address for write\r\n    CPUGET EDX,43 // Internal memory size\r\n    SUB EDI,128*8 // Subtract page address from it\r\n    MUL EDI,2 // Force position to be even(char pos)\r\n    MOV ECX,EDI // Diagonal position\r\n    MOV EBX,EDI // Horizontal Position\r\n    MUL EDI,30 // Convert char pos to be line pos instead\r\n    ADD ECX,EDI // Get diagonal position by adding line to char pos\r\n\r\n    // Print vertical character\r\n    MOV [EDX:EDI],EAX \r\n    INC EDI // On odd offsets we need to write color\r\n    MOV [EDX:EDI],999 // write color to screen\r\n    // Print horizontal character\r\n    MOV [EDX:EBX],EAX\r\n    INC EBX\r\n    MOV [EDX:EBX],999\r\n    // Print diagonal character\r\n    MOV [EDX:ECX],EAX\r\n    INC ECX\r\n    MOV [EDX:ECX],999\r\n\r\n    CPUGET EAX,28 // Get LINT to check if we failed any memory I/O\r\n    CMP EAX,29 // Check if we're in our own interrupt\r\n    JNE shutdown\r\n    CPUSET 42,5   // Set MEMRQ to 5 to signify write was handled\r\nCLERR\r\nSTI\r\nIRET\r\n\r\nshutdown:\r\nSTI\r\nCLM\r\nCLEF\r\nINT EAX // repeat error now that we're not in extended mode\r\n\r\nCODE\r\nSTEF // Set extended flag for interrupt handling\r\nCPUSET 37,page_table // Load page table ptr into PTBL register\r\nCPUSET 38,16 // Set page table entries in PTBE register\r\nLIDTR interrupt_table\r\n\r\nMOV EAX,0\r\n// Since only Readable/Writable/Executable are accessible via\r\n// the SPP Instruction, we have to manually create a permissions\r\n// mask for our new pages.\r\n\r\n// Using SBIT isn't entirely necessary, to get the number below you can also\r\n// use the constant 232(calculated from 8+32+64+128)\r\nSBIT EAX,3 // (8)   Read & Write calls int 28(read) and int 29(write)\r\nSBIT EAX,5 // (32)  Readable\r\nSBIT EAX,6 // (64)  Writable\r\nSBIT EAX,7 // (128) Executable\r\nADD EAX,(256*2)\r\n// Runlevel can be obtained from the permission mask with floor(pmask/256)%256\r\n// To set the runlevel, add 256*runlevel to the permission mask\r\nMOV ECX,3 // Set 2 pages\r\nMOV EBX,7*2 // Starting from page 8\r\nADD EBX,page_table\r\n\r\npage_set_loop:\r\n    MOV EDI,ECX\r\n    MUL EDI,2\r\n    MOV [EBX:EDI],EAX // Page byte 0 is the permission mask of the page\r\n    INC EDI // Access page byte 1\r\n    MOV [EBX:EDI],0 // Page byte 1 is the page this redirects to if the mapped flag is set\r\nLOOP page_set_loop\r\n\r\nSTM // Set Memory flag to enable memory paging features\r\n\r\n/*\r\nNote that, unlike regular console screen prints\r\nthis doesn't need to write character to even indexes\r\nand color to odd indexes, since those are both handled\r\nby interrupt 29(write_mem), so we can treat this like\r\na regular section of memory.\r\n*/\r\n\r\nMOV R0,128*8 // Get first index of page 8\r\nMOV ESI,str\r\n\r\nprint_loop:\r\nMOV [R0],[ESI]\r\nINC R0\r\nINC ESI\r\nCMP [ESI],0\r\nJNE print_loop\r\n\r\nCLEF // Disable interrupt handling\r\nINT 2 // End execution.\r\n\r\nstr:\r\nDB \"Hello Wiremod!\",0\r\n"},"cpuchip/lib/":{"cpuchip/lib/zcrt/":{"cpuchip/lib/zcrt/string.txt":"//------------------------------------------------------------------------------\r\n// ZCPU CRT sourcecode (for HL-ZASM compiler)         (C) 2011 by Black Phoenix\r\n//\r\n// String library. Contains functions to work with C strings (C89-compatible)\r\n//------------------------------------------------------------------------------\r\n\r\n#define NULL 0\r\n\r\n//copies n bytes between two memory areas; if there is overlap, the behavior is undefined\r\nvoid *memcpy(void *dest, void *src, float n) {\r\n  preserve esi,edi;\r\n  register float rem;\r\n\r\n  esi = src;\r\n  edi = dest;\r\n  rem = n;\r\n  while (rem) {\r\n    register float count = rem;\r\n    min count,8192;\r\n    mcopy count;\r\n    rem = rem - count;\r\n  }\r\n  return dest;\r\n}\r\n\r\n//copies n bytes between two memory areas; unlike with memcpy the areas may overlap\r\n//void *memmove(void *dest, void *src, float n);\r\n#define memmove memcpy\r\n\r\n//returns a pointer to the first occurrence of c in the first n bytes of s, or NULL if not found\r\nvoid* memchr(void *s, float c, float n) {\r\n  register void *r = s;\r\n  register float rem = n;\r\n\r\n  while (rem) {\r\n    if (*r == c) {\r\n      return r;\r\n    }\r\n    ++r;\r\n    --rem;\r\n  }\r\n\r\n  return NULL;\r\n}\r\n\r\n//compares the first n bytes of two memory areas\r\n//int memcmp(const void *s1, const void *s2, float n);\r\n#define memcmp strcmp\r\n\r\n//overwrites a memory area with n copies of c\r\nvoid* memset(void *ptr, float c, float n) {\r\n  register void *p = ptr;\r\n  register float rem = n;\r\n  register float ch = c;\r\n\r\n  while (rem) {\r\n    *p++ = ch;\r\n    --rem;\r\n  }\r\n\r\n  return ptr;\r\n}\r\n\r\n//appends the string src to dest\r\nchar* strcat(char *src, *dest) {\r\n  register char *srcptr, *destptr;\r\n\r\n  srcptr = src;\r\n  while (*++srcptr) ;\r\n\r\n  destptr = dest;\r\n  while (*srcptr++ = *destptr++) ;\r\n  return src;\r\n}\r\n\r\n//appends at most n bytes of the string src to dest\r\nchar* strncat(char *src, *dest, float n) {\r\n  register char *srcptr, *destptr;\r\n  register float i;\r\n\r\n  srcptr = src;\r\n  srcptr--;\r\n  while (*++srcptr) ;\r\n\r\n  destptr = dest;\r\n  i = n;\r\n  while (i--) {\r\n    if (*srcptr++ = *destptr++) continue;\r\n  }\r\n  *srcptr = 0;\r\n  return src;\r\n}\r\n\r\n//locates character c in a string, searching from the beginning\r\nchar* strchr(char *str, c) {\r\n  register char *strptr, ch;\r\n  strptr = str;\r\n  ch = c;\r\n  while(*strptr) {\r\n    if (*strptr == ch) return strptr;\r\n    ++strptr;\r\n  }\r\n  return 0;\r\n}\r\n\r\n//locates character c in a string, searching from the end\r\nchar* strrchr(char *str, c) {\r\n  register char *strptr, ch;\r\n  register char *findptr;\r\n\r\n  findptr = 0;\r\n  strptr = str;\r\n  ch = c;\r\n  while (*strptr) {\r\n    if (*strptr == ch) findptr = strptr;\r\n    ++strptr;\r\n  }\r\n  return findptr;\r\n}\r\n\r\n//compares two strings lexicographically\r\nfloat strcmp(char *src, *dest) {\r\n  register char *srcptr, *destptr;\r\n\r\n  srcptr = src;\r\n  destptr = dest;\r\n  while (*srcptr == *destptr) {\r\n    if (*srcptr == 0) return 0;\r\n    ++srcptr; ++destptr;\r\n  }\r\n  return (*srcptr - *destptr);\r\n}\r\n\r\n//compares up to the first n bytes of two strings lexicographically\r\nfloat strncmp(char *src, *dest, float n) {\r\n  register char *srcptr, *destptr;\r\n  register float i;\r\n\r\n  srcptr = src;\r\n  destptr = dest;\r\n  i = n;\r\n\r\n  while (i && (*srcptr == *destptr)) {\r\n    if (*srcptr == 0) return 0;\r\n    ++srcptr; ++destptr; --i;\r\n  }\r\n  if (i) return (*srcptr - *destptr);\r\n  return 0;\r\n}\r\n\r\n//copies a string from one location to another\r\nchar* strcpy(char *dest, *src) {\r\n  register char *srcptr, *destptr;\r\n\r\n  destptr = dest;\r\n  srcptr = src;\r\n  while (*destptr++ = *srcptr++) ;\r\n  return dest;\r\n}\r\n\r\n\r\n//write exactly n bytes to dest, copying from src or add 0's\r\nchar* strncpy(char *dest, *src, float n) {\r\n  register char *srcptr, *destptr;\r\n  register float i;\r\n\r\n  destptr = dest;\r\n  srcptr = src;\r\n  i = n;\r\n\r\n  while (i-- > 0) {\r\n    if (*destptr++ = *srcptr++) continue;\r\n    while (i-- > 0) *destptr++ = 0;\r\n  }\r\n  *destptr = 0;\r\n  return dest;\r\n}\r\n\r\n//returns the string representation of an error number e.g. errno\r\n//char *strerror(int);\r\n\r\n//finds the length of a C string\r\nfloat strlen(char* str) {\r\n  register char* strptr;\r\n  register float n;\r\n\r\n  strptr = str;\r\n  n = 0;\r\n  while (*strptr++) n++;\r\n  return n;\r\n}\r\n\r\n//determines the length of the maximal initial substring consisting entirely of characters in accept\r\nfloat strspn(char *str, *accept) {\r\n  register char *s = str;\r\n  register char *p = accept;\r\n\r\n  while (*p) {\r\n    if (*p++ == *s) {\r\n      ++s;\r\n      p = accept;\r\n    }\r\n  }\r\n  return s - str;\r\n}\r\n\r\n//determines the length of the maximal initial substring consisting entirely of characters not in reject\r\nfloat strcspn(char *str, char *reject) {\r\n  register char *s, *p;\r\n\r\n  for (s=str; *s; s++) {\r\n    for (p=reject; *p; p++) {\r\n      if (*p == *s) goto done;\r\n    }\r\n  }\r\n  done:\r\n  return s - str;\r\n}\r\n\r\n//finds the first occurrence of any character in accept\r\nchar* strpbrk(char *str, char *accept) {\r\n  register char *s;\r\n  register char *p;\r\n\r\n  for (s=str; *s; s++) {\r\n    for (p=accept; *p; p++) {\r\n      if (*p == *s) return s;\r\n    }\r\n  }\r\n  return NULL;\r\n}\r\n\r\n//finds the first occurrence of the string \"needle\" in the longer string \"haystack\"\r\nchar *strstr(char *haystack, char *needle) {\r\n  register char *s = haystack;\r\n  register char *p = needle;\r\n\r\n  while (1) {\r\n    if (!*p) {\r\n      return haystack;\r\n    }\r\n    if (*p == *s) {\r\n      ++p;\r\n      ++s;\r\n    } else {\r\n      p = needle;\r\n      if (!*s) {\r\n        return NULL;\r\n      }\r\n      s = ++haystack;\r\n    }\r\n  }\r\n}\r\n\r\n//parses a string into a sequence of tokens; non-thread safe in the spec, non-reentrant\r\n//char *strtok(char *, const char * delim);\r\n\r\n//transforms src into a collating form, such that the numerical sort order of the transformed string is equivalent to the collating order of src\r\n//float strxfrm(char *dest, const char *src, float n);\r\n","cpuchip/lib/zcrt/init.txt":"//------------------------------------------------------------------------------\r\n// ZCPU CRT sourcecode (for HL-ZASM compiler)         (C) 2011 by Black Phoenix\r\n//\r\n// C runtime library initialization\r\n//------------------------------------------------------------------------------\r\n\r\n#ifdef ZCRT_EXTENDED_MODE\r\n  // Initialize extended mode\r\n  mov edi,&zcrtInterruptTable; //Need \"&\" because array is defined below\r\n  mov esi,&zcrtInterruptTable; add esi,1024;\r\n  @InitTable:\r\n    mov #edi,zcrtErrorHandler; inc edi;\r\n    mov #edi,0;                inc edi;\r\n    mov #edi,0;                inc edi;\r\n    mov #edi,32;               inc edi;\r\n    cmp edi,esi;\r\n    jl @InitTable;\r\n\r\n  lidtr zcrtInterruptTable;\r\n  stef;\r\n#endif\r\n\r\n// Call main function\r\nmain();\r\n\r\n// Stop the processor execution\r\n#ifdef ZCRT_EXTENDED_MODE\r\n  clef;\r\n#endif\r\nint 1;\r\n\r\n//------------------------------------------------------------------------------\r\n// Allocate the interrupt table\r\n#ifdef ZCRT_EXTENDED_MODE\r\n  float zcrtInterruptTable[1024];\r\n  char* zcrtInterruptEntrypoint;\r\n\r\n  // Default interrupt handlers\r\n  zcrtErrorHandler:\r\n    //Execute handler if required\r\n    if (zcrtInterruptEntrypoint) {\r\n      float errorNo,errorCode;\r\n      cpuget errorNo,28;\r\n      cpuget errorCode,27;\r\n\r\n      zcrtInterruptEntrypoint(errorNo,errorCode);\r\n    }\r\n  iret\r\n#endif\r\n","cpuchip/lib/zcrt/ctype.txt":"//------------------------------------------------------------------------------\r\n// ZCPU CRT sourcecode (for HL-ZASM compiler)         (C) 2011 by Black Phoenix\r\n//\r\n// Character classification functions.\r\n//------------------------------------------------------------------------------\r\n\r\n#define _CONTROL 1\r\n#define _SPACE   2\r\n#define _BLANK   4\r\n#define _DIGIT   8\r\n#define _HEX     16\r\n#define _PUNCT   32\r\n#define _UPPER   64\r\n#define _LOWER   128\r\n#define _GRAPH   256\r\n\r\n#define _MAXCHARS 0x83\r\n\r\n//test for alphanumeric character\r\nfloat isalnum(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_LOWER+_UPPER+_DIGIT;\r\n}\r\n\r\n//test for alphabetic character\r\nfloat isalpha(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_LOWER+_UPPER;\r\n}\r\n\r\n//test for blank character\r\nfloat isblank(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_BLANK;\r\n}\r\n\r\n//test for control character\r\nfloat iscontrol(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_CONTROL;\r\n}\r\n\r\n//test for digit\r\nfloat isdigit(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_DIGIT;\r\n}\r\n\r\n//test for graphic character, excluding the space character\r\nfloat isgraph(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_GRAPH;\r\n}\r\n\r\n//test for lowercase character\r\nfloat islower(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_LOWER;\r\n}\r\n\r\n//test for printable character, including the space character.\r\nfloat isprint(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_LOWER+_UPPER+_DIGIT+_PUNCT+_BLANK+_GRAPH;\r\n}\r\n\r\n//test for punctuation character\r\nfloat ispunct(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_PUNCT;\r\n}\r\n\r\n//test for any whitespace character\r\nfloat isspace(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_SPACE;\r\n}\r\n\r\n//test for uppercase character\r\nfloat isupper(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_UPPER;\r\n}\r\n\r\n//test for hexadecimal digit. Not locale-specific.\r\nfloat isxdigit(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_HEX;\r\n}\r\n\r\n//convert character to lowercase\r\nchar tolower(char c) {\r\n  if (islower(c)) return c - 0x20;\r\n  return c;\r\n}\r\n\r\n//convert character to uppercase\r\nchar toupper(char c) {\r\n  if (isupper(c)) return c + 0x20;\r\n  return c;\r\n}\r\n\r\n__ctype_characters:\r\n  db _CONTROL,        //00 (NUL)\r\n  db _CONTROL;        //01 (SOH)\r\n  db _CONTROL;        //02 (STX)\r\n  db _CONTROL;        //03 (ETX)\r\n  db _CONTROL;        //04 (EOT)\r\n  db _CONTROL;        //05 (ENQ)\r\n  db _CONTROL;        //06 (ACK)\r\n  db _CONTROL;        //07 (BEL)\r\n  db _CONTROL;        //08 (BS)\r\n  db _SPACE+_CONTROL; //09 (HT)\r\n  db _SPACE+_CONTROL; //0A (LF)\r\n  db _SPACE+_CONTROL; //0B (VT)\r\n  db _SPACE+_CONTROL; //0C (FF)\r\n  db _SPACE+_CONTROL; //0D (CR)\r\n  db _CONTROL;        //0E (SI)\r\n  db _CONTROL;        //0F (SO)\r\n  db _CONTROL;        //10 (DLE)\r\n  db _CONTROL;        //11 (DC1)\r\n  db _CONTROL;        //12 (DC2)\r\n  db _CONTROL;        //13 (DC3)\r\n  db _CONTROL;        //14 (DC4)\r\n  db _CONTROL;        //15 (NAK)\r\n  db _CONTROL;        //16 (SYN)\r\n  db _CONTROL;        //17 (ETB)\r\n  db _CONTROL;        //18 (CAN)\r\n  db _CONTROL;        //19 (EM)\r\n  db _CONTROL;        //1A (SUB)\r\n  db _CONTROL;        //1B (ESC)\r\n  db _CONTROL;        //1C (FS)\r\n  db _CONTROL;        //1D (GS)\r\n  db _CONTROL;        //1E (RS)\r\n  db _CONTROL;        //1F (US)\r\n  db _SPACE+_BLANK;   //20 SPACE\r\n  db _PUNCT;          //21 !\r\n  db _PUNCT;          //22 \"\r\n  db _PUNCT;          //23 #\r\n  db _PUNCT;          //24 $\r\n  db _PUNCT;          //25 %\r\n  db _PUNCT;          //26 &\r\n  db _PUNCT;          //27 '\r\n  db _PUNCT;          //28 (\r\n  db _PUNCT;          //29 )\r\n  db _PUNCT;          //2A *\r\n  db _PUNCT;          //2B +\r\n  db _PUNCT;          //2C ;\r\n  db _PUNCT;          //2D -\r\n  db _PUNCT;          //2E .\r\n  db _PUNCT;          //2F /\r\n  db _DIGIT+_HEX;     //30 0\r\n  db _DIGIT+_HEX;     //31 1\r\n  db _DIGIT+_HEX;     //32 2\r\n  db _DIGIT+_HEX;     //33 3\r\n  db _DIGIT+_HEX;     //34 4\r\n  db _DIGIT+_HEX;     //35 5\r\n  db _DIGIT+_HEX;     //36 6\r\n  db _DIGIT+_HEX;     //37 7\r\n  db _DIGIT+_HEX;     //38 8\r\n  db _DIGIT+_HEX;     //39 9\r\n  db _PUNCT;          //3A :\r\n  db _PUNCT;          //3B ;\r\n  db _PUNCT;          //3C <\r\n  db _PUNCT;          //3D =\r\n  db _PUNCT;          //3E >\r\n  db _PUNCT;          //3F ?\r\n  db _PUNCT;          //40 @\r\n  db _UPPER+_HEX;     //41 A\r\n  db _UPPER+_HEX;     //42 B\r\n  db _UPPER+_HEX;     //43 C\r\n  db _UPPER+_HEX;     //44 D\r\n  db _UPPER+_HEX;     //45 E\r\n  db _UPPER+_HEX;     //46 F\r\n  db _UPPER;          //47 G\r\n  db _UPPER;          //48 H\r\n  db _UPPER;          //49 I\r\n  db _UPPER;          //4A J\r\n  db _UPPER;          //4B K\r\n  db _UPPER;          //4C L\r\n  db _UPPER;          //4D M\r\n  db _UPPER;          //4E N\r\n  db _UPPER;          //4F O\r\n  db _UPPER;          //50 P\r\n  db _UPPER;          //51 Q\r\n  db _UPPER;          //52 R\r\n  db _UPPER;          //53 S\r\n  db _UPPER;          //54 T\r\n  db _UPPER;          //55 U\r\n  db _UPPER;          //56 V\r\n  db _UPPER;          //57 W\r\n  db _UPPER;          //58 X\r\n  db _UPPER;          //59 Y\r\n  db _UPPER;          //5A Z\r\n  db _PUNCT;          //5B [\r\n  db _PUNCT;          //5C \\\r\n  db _PUNCT;          //5D ]\r\n  db _PUNCT;          //5E ^\r\n  db _PUNCT;          //5F _\r\n  db _PUNCT;          //60 `\r\n  db _LOWER+_HEX;     //61 a\r\n  db _LOWER+_HEX;     //62 b\r\n  db _LOWER+_HEX;     //63 c\r\n  db _LOWER+_HEX;     //64 d\r\n  db _LOWER+_HEX;     //65 e\r\n  db _LOWER+_HEX;     //66 f\r\n  db _LOWER;          //67 g\r\n  db _LOWER;          //68 h\r\n  db _LOWER;          //69 i\r\n  db _LOWER;          //6A j\r\n  db _LOWER;          //6B k\r\n  db _LOWER;          //6C l\r\n  db _LOWER;          //6D m\r\n  db _LOWER;          //6E n\r\n  db _LOWER;          //6F o\r\n  db _LOWER;          //70 p\r\n  db _LOWER;          //71 q\r\n  db _LOWER;          //72 r\r\n  db _LOWER;          //73 s\r\n  db _LOWER;          //74 t\r\n  db _LOWER;          //75 u\r\n  db _LOWER;          //76 v\r\n  db _LOWER;          //77 w\r\n  db _LOWER;          //78 x\r\n  db _LOWER;          //79 y\r\n  db _LOWER;          //7A z\r\n  db _PUNCT;          //7B {\r\n  db _PUNCT;          //7C |\r\n  db _PUNCT;          //7D }\r\n  db _PUNCT;          //7E ~\r\n  db _CONTROL;        //7F (DEL)\r\n\r\n  db _GRAPH;          //80\r\n  db _GRAPH;          //81\r\n  db _GRAPH;          //82\r\n  db _GRAPH;          //83\r\n"},"cpuchip/lib/drivers/":{"cpuchip/lib/drivers/drv_cscr.txt":"//------------------------------------------------------------------------------\r\n// ZCPU standard library and drivers set              (C) 2011 by Black Phoenix\r\n//\r\n// UDH-enabled console screen highspeed driver\r\n//------------------------------------------------------------------------------\r\n\r\n//Define to check if console screen driver is available\r\n#define CSCR_DRIVER\r\n\r\n//Maximum number of console screens supported\r\n#define MAX_CONSOLE_SCREENS 8\r\n\r\n//Console screen registers\r\n#define CURSOR_RATE       2043\r\n#define CURSOR_SIZE       2044\r\n#define CURSOR_POSITION   2045\r\n#define CURSOR_VISIBLE    2046\r\n#define LOW_SHIFT_COL     2031\r\n#define HIGH_SHIFT_COL    2032\r\n#define LOW_SHIFT_ROW     2033\r\n#define HIGH_SHIFT_ROW    2034\r\n#define SHIFT_ROWS        2038\r\n#define SHIFT_CELLS       2037\r\n#define CLEAR_SCREEN      2041\r\n#define BACKGROUND_COLOR  2042\r\n#define SCREEN_ACTIVE     2047\r\n#define SCREEN_ROTATION   2024\r\n#define SCREEN_BRIGHTNESS 2036\r\n\r\n//Driver data\r\nchar* cscrOffsets[MAX_CONSOLE_SCREENS];\r\nfloat cscrDevices[MAX_CONSOLE_SCREENS];\r\nchar* cscrCharacterPointer[MAX_CONSOLE_SCREENS];\r\nfloat cscrSelectedScreen;\r\n\r\n#ifdef UDH_DRIVER\r\n//Update console screen offsets\r\nvoid cscrUDHQueryFunction() {\r\n  float i,n;\r\n  n = udhGetDevices(11,MAX_CONSOLE_SCREENS,cscrDevices);\r\n  for (i = 0; i < n; i++) {\r\n    cscrOffsets[i] = udhGetDeviceOffset(cscrDevices[i]);\r\n  }\r\n}\r\n#endif\r\n\r\n//Initialize console screen driver. screenOffset may be 0 if using UDH\r\nvoid cscrInitialize(char* screenOffset) {\r\n  float i;\r\n\r\n  for (i = 0; i < MAX_CONSOLE_SCREENS; i++) {\r\n    cscrOffsets[i] = screenOffset;\r\n  }\r\n\r\n#ifdef UDH_DRIVER\r\n    if (!screenOffset) {\r\n      udhRegisterDriver(cscrUDHQueryFunction);\r\n      cscrUDHQueryFunction();\r\n    }\r\n#endif\r\n  cscrSelectedScreen = 0;\r\n}\r\n\r\nfloat cscrPresent(float screen) {\r\n  return cscrOffsets[cscrSelectedScreen] != 0;\r\n}\r\n\r\nvoid cscrSelect(float screen) {\r\n  cscrSelectedScreen = screen;\r\n  max cscrSelectedScreen,0;\r\n  min cscrSelectedScreen,MAX_CONSOLE_SCREENS;\r\n}\r\n\r\nvoid cscrSetActive(float clk) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;\r\n  *(cscrOffsets[cscrSelectedScreen]+SCREEN_ACTIVE) = clk;\r\n}\r\n\r\nvoid cscrClear() {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;\r\n  *(cscrOffsets[cscrSelectedScreen]+CLEAR_SCREEN) = 1;\r\n  cscrCharacterPointer[cscrSelectedScreen] = 0;\r\n}\r\n\r\nvoid cscrSetBackground(float col) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;\r\n  *(cscrOffsets[cscrSelectedScreen]+BACKGROUND_COLOR) = col;\r\n}\r\n\r\nvoid cscrSetRotation(float rot) {\r\n  *(cscrOffsets[cscrSelectedScreen]+SCREEN_ROTATION) = rot;\r\n}\r\n\r\nvoid cscrSetBrightness(float bright) {\r\n  *(cscrOffsets[cscrSelectedScreen]+SCREEN_BRIGHTNESS) = bright;\r\n}\r\n\r\nvoid cscrLoadImage(char* imgdata) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;\r\n\r\n  preserve ESI,EDI;\r\n  ESI = imgdata;\r\n  EDI = cscrOffsets[cscrSelectedScreen];\r\n  mcopy 30*18*2;\r\n}\r\n\r\nvoid cscrPutLine(char* scrptr, float col, char* str) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;\r\n  char* curptr = scrptr;\r\n\r\n  while (*str) {\r\n    *(cscrOffsets[cscrSelectedScreen]+curptr*2+0) = *str;\r\n    *(cscrOffsets[cscrSelectedScreen]+curptr*2+1) = col;\r\n\r\n    str++;\r\n    curptr++;\r\n  }\r\n}\r\n\r\nvoid cscrPutChar(char* scrptr, float col, char ch) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;\r\n\r\n  *(cscrOffsets[cscrSelectedScreen]+scrptr*2+0) = ch;\r\n  *(cscrOffsets[cscrSelectedScreen]+scrptr*2+1) = col;\r\n}\r\n\r\nvoid cscrNewLine() {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;\r\n\r\n  cscrCharacterPointer[cscrSelectedScreen] /= 30;\r\n  fint cscrCharacterPointer[cscrSelectedScreen];\r\n  cscrCharacterPointer[cscrSelectedScreen] = (cscrCharacterPointer[cscrSelectedScreen]+1)*30;\r\n\r\n  if (cscrCharacterPointer[cscrSelectedScreen] >= 30*18) {\r\n    cscrCharacterPointer[cscrSelectedScreen] = cscrCharacterPointer[cscrSelectedScreen] - 30;\r\n    *(cscrOffsets[cscrSelectedScreen]+SHIFT_ROWS) = 1;\r\n  }\r\n}\r\n\r\nvoid cscrPrintLine(char* str, float col) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;\r\n\r\n  while (*str) {\r\n    if (*str == '\\n') {\r\n      cscrNewLine();\r\n      str++;\r\n      if (*str == 0) return;\r\n    }\r\n\r\n    *(cscrOffsets[cscrSelectedScreen]+cscrCharacterPointer[cscrSelectedScreen]*2+0) = *str;\r\n    *(cscrOffsets[cscrSelectedScreen]+cscrCharacterPointer[cscrSelectedScreen]*2+1) = col;\r\n\r\n    cscrCharacterPointer[cscrSelectedScreen]++;\r\n    if (cscrCharacterPointer[cscrSelectedScreen] >= 30*18) cscrNewLine();\r\n    str++;\r\n  }\r\n}\r\n\r\nvoid cscrPrintNumber(float num, float col) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;\r\n\r\n  float ndig,a;\r\n  a = num;\r\n  ndig = 0;\r\n  while (a > 0) {\r\n    ndig++;\r\n    a /= 10;\r\n    fint a;\r\n  }\r\n  max ndig,1;\r\n  a = num;\r\n\r\n  cscrCharacterPointer[cscrSelectedScreen] = cscrCharacterPointer[cscrSelectedScreen] + ndig;\r\n  char* charPtr = cscrCharacterPointer[cscrSelectedScreen] - 1;\r\n  while (ndig > 0) {\r\n    preserve EDX;\r\n    mov EDX,a;\r\n    mod EDX,10;\r\n    add EDX,48;\r\n\r\n    *(cscrOffsets[cscrSelectedScreen]+charPtr*2+0) = EDX;\r\n    *(cscrOffsets[cscrSelectedScreen]+charPtr*2+1) = col;\r\n    charPtr--;\r\n\r\n    a /= 10;\r\n    fint a;\r\n\r\n    ndig--;\r\n  }\r\n}\r\n\r\nvoid cscrSetCursor(float x, y) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;\r\n  cscrCharacterPointer[cscrSelectedScreen] = x+y*30;\r\n}\r\n","cpuchip/lib/drivers/drv_udh.txt":"//------------------------------------------------------------------------------\r\n// ZCPU standard library and drivers set              (C) 2011 by Black Phoenix\r\n//\r\n// Universal device host driver. Only supports 8 devices right now\r\n//------------------------------------------------------------------------------\r\n\r\n#define UDH_DRIVER\r\n\r\n//Maximum number of devices supported\r\n#define MAX_UDH_DEVICES 8\r\n\r\n//Address range of a single device\r\n#define MAX_UDH_ADDRESS_RANGE 4*1024\r\n\r\n//Maximum number of drivers that may register with UDH\r\n#define MAX_UDH_DRIVERS 8\r\n\r\n//Device name/string data\r\nstring udhDeviceString0,\"None\";\r\nstring udhDeviceString1,\"Unknown\";\r\nstring udhDeviceString2,\"Extended bus\";\r\nstring udhDeviceString3,\"Address bus\";\r\nstring udhDeviceString4,\"Zyelios CPU\";\r\nstring udhDeviceString5,\"Zyelios GPU\";\r\nstring udhDeviceString6,\"Zyelios SPU\";\r\nstring udhDeviceString7,\"Flash EEPROM\";\r\nstring udhDeviceString8,\"ROM\";\r\nstring udhDeviceString9,\"Data bus\";\r\nstring udhDeviceString10,\"CD Ray\";\r\nstring udhDeviceString11,\"Console screen\";\r\nstring udhDeviceString12,\"Digital screen\";\r\nstring udhDeviceString13,\"Data plug\";\r\nstring udhDeviceString14,\"Data socket\";\r\nstring udhDeviceString15,\"Keyboard\";\r\nstring udhDeviceString16,\"Oscilloscope\";\r\nstring udhDeviceString17,\"Sound emitter\";\r\nstring udhDeviceString18,\"Constant value\";\r\nstring udhDeviceString19,\"Data port\";\r\nstring udhDeviceString20,\"RAM\";\r\nudhDeviceName:\r\n  db udhDeviceString0, udhDeviceString1, udhDeviceString2;\r\n  db udhDeviceString3, udhDeviceString4, udhDeviceString5;\r\n  db udhDeviceString6, udhDeviceString7, udhDeviceString8;\r\n  db udhDeviceString9, udhDeviceString10,udhDeviceString11;\r\n  db udhDeviceString12,udhDeviceString13,udhDeviceString14;\r\n  db udhDeviceString15,udhDeviceString16,udhDeviceString17;\r\n  db udhDeviceString18,udhDeviceString19,udhDeviceString20;\r\n\r\n//Extended bus offset\r\nchar* udhBusOffset;\r\n\r\n//List of callbacks to call when querying devices\r\nvoid* udhQueryCallback[MAX_UDH_DRIVERS];\r\nfloat udhQueryCallbackCount = 0;\r\n\r\nfloat udhSetBusAddress(char* extOffset) {\r\n  udhBusOffset = extOffset;\r\n  udhQueryDevices();\r\n}\r\n\r\nvoid udhQueryDevices() {\r\n  float i;\r\n\r\n  //Run the query\r\n  udhBusOffset[16] = 32+MAX_UDH_DEVICES;\r\n  udhBusOffset[17] = 1;\r\n\r\n  //Reconfigure all devices\r\n  //FIXME: only supports single extended bus right now\r\n  for (i = 0; i < 8; i++) {\r\n    udhBusOffset[i*2+0] = (4*1024)*i;\r\n    udhBusOffset[i*2+1] = (4*1024)*i+((4*1024)-1);\r\n  }\r\n\r\n  //Update all drivers\r\n  for (i = 0; i < udhQueryCallbackCount; i++) {\r\n    void* functionPtr = udhQueryCallback[i];\r\n    functionPtr();\r\n  }\r\n}\r\n\r\nvoid udhRegisterDriver(void* queryDeviceFunction) {\r\n  udhQueryCallback[udhQueryCallbackCount] = queryDeviceFunction;\r\n  if (udhQueryCallbackCount < MAX_UDH_DRIVERS) udhQueryCallbackCount++;\r\n}\r\n\r\nfloat udhGetDeviceType(float busIndex) {\r\n  return udhBusOffset[32+busIndex];\r\n}\r\n\r\nfloat udhGetDeviceOffset(float busIndex) {\r\n  return 65536+32+MAX_UDH_DEVICES+udhBusOffset[busIndex*2];\r\n}\r\n\r\nchar* udhGetDeviceName(float busIndex) {\r\n  float deviceType = udhGetDeviceType(busIndex);\r\n  if ((deviceType >= 0) && (deviceType <= 20)) {\r\n    return udhDeviceName[deviceType];\r\n  } else {\r\n    return udhDeviceName[1];\r\n  }\r\n}\r\n\r\nvoid udhSetDeviceOffsetSize(float busIndex, char* offst, char* size) {\r\n  udhBusOffset[busIndex*2+0] = offst;\r\n  udhBusOffset[busIndex*2+1] = offst+size-1;\r\n}\r\n\r\nfloat udhGetNumDevices() {\r\n  return MAX_UDH_DEVICES;\r\n}\r\n\r\nfloat udhGetDevices(float type, float maxCount, char* deviceList) {\r\n  float i,devPtr,n;\r\n\r\n  devPtr = deviceList;\r\n  n = 0;\r\n  for (i = 0; i < MAX_UDH_DEVICES; i++) {\r\n    if ((udhGetDeviceType(i) == type) && (n < maxCount)) {\r\n      n++;\r\n      *devPtr++ = i;\r\n    }\r\n  }\r\n\r\n  return n;\r\n}\r\n"}}}}